/**
 * Transparency Service for AI-generated responses (Issue #187)
 * 
 * This service handles the application of transparency disclaimers to AI-generated
 * roasts based on user preferences for OpenAI compliance and platform policies.
 */

const { supabaseServiceClient } = require('../config/supabase');
const { logger } = require('../utils/logger');
const { flags } = require('../config/flags');

class TransparencyService {
  constructor() {
    this.defaultBioText = {
      es: 'Respuestas a comentarios inapropiados proporcionados por @Roastr.AI',
      en: 'Inappropriate comment responses provided by @Roastr.AI'
    };
    
    this.defaultSignature = {
      es: '‚Äî Generado por Roastr.AI',
      en: '‚Äî Generated by Roastr.AI'
    };
  }

  /**
   * Get user's transparency mode preference
   * @param {string} userId - User ID
   * @returns {Promise<string>} - Transparency mode ('bio', 'signature', 'creative')
   */
  async getUserTransparencyMode(userId) {
    try {
      if (!flags.isEnabled('ENABLE_SUPABASE')) {
        return 'bio'; // Default for mock mode
      }

      const { data, error } = await supabaseServiceClient
        .from('users')
        .select('transparency_mode, language')
        .eq('id', userId)
        .single();

      if (error) {
        logger.warn('Failed to get user transparency mode, using default', { 
          userId: userId.substring(0, 8) + '...', 
          error: error.message 
        });
        return 'bio';
      }

      return data.transparency_mode || 'bio';
    } catch (error) {
      logger.error('Error getting user transparency mode:', error);
      return 'bio';
    }
  }

  /**
   * Get a random creative disclaimer from the database
   * @param {string} language - Language code (es, en)
   * @returns {Promise<string>} - Random creative disclaimer
   */
  async getRandomDisclaimer(language = 'es') {
    try {
      if (!flags.isEnabled('ENABLE_SUPABASE')) {
        // Mock disclaimers for testing
        const mockDisclaimers = {
          es: [
            'Ning√∫n humano perdi√≥ tiempo en ti',
            'Powered by Roastr‚Ñ¢ ‚Äî salvo contigo',
            '0% humano, 100% devastador'
          ],
          en: [
            'No humans wasted time on you',
            'Powered by Roastr‚Ñ¢ ‚Äî except for you',
            '0% human, 100% devastating'
          ]
        };
        
        const disclaimers = mockDisclaimers[language] || mockDisclaimers.es;
        return disclaimers[Math.floor(Math.random() * disclaimers.length)];
      }

      // Use database function for weighted random selection
      const { data, error } = await supabaseServiceClient
        .rpc('get_random_disclaimer', { user_language: language });

      if (error) {
        logger.warn('Failed to get random disclaimer from database', { 
          language, 
          error: error.message 
        });
        // Fallback to default signature
        return this.defaultSignature[language] || this.defaultSignature.es;
      }

      return data || this.defaultSignature[language] || this.defaultSignature.es;
    } catch (error) {
      logger.error('Error getting random disclaimer:', error);
      return this.defaultSignature[language] || this.defaultSignature.es;
    }
  }

  /**
   * Apply transparency disclaimer to roast based on user preference
   * @param {string} roastText - Original roast text
   * @param {string} userId - User ID
   * @param {string} language - Language code (es, en)
   * @returns {Promise<Object>} - { finalText, transparencyMode, disclaimer }
   */
  async applyTransparencyDisclaimer(roastText, userId, language = 'es') {
    try {
      const transparencyMode = await this.getUserTransparencyMode(userId);
      
      let finalText = roastText;
      let disclaimer = null;

      switch (transparencyMode) {
        case 'bio':
          // No modification to the roast - user should add disclaimer to bio
          finalText = roastText;
          disclaimer = this.defaultBioText[language] || this.defaultBioText.es;
          break;

        case 'signature':
          // Append fixed signature
          disclaimer = this.defaultSignature[language] || this.defaultSignature.es;
          finalText = roastText + '\n\n' + disclaimer;
          break;

        case 'creative':
          // Append random creative disclaimer
          disclaimer = await this.getRandomDisclaimer(language);
          finalText = roastText + '\n\n' + disclaimer;
          break;

        default:
          // Fallback to bio mode
          finalText = roastText;
          disclaimer = this.defaultBioText[language] || this.defaultBioText.es;
      }

      logger.info('üîç Transparency disclaimer applied', {
        userId: userId.substring(0, 8) + '...',
        mode: transparencyMode,
        language,
        hasDisclaimer: finalText !== roastText
      });

      return {
        finalText,
        transparencyMode,
        disclaimer,
        bioText: transparencyMode === 'bio' ? disclaimer : null
      };

    } catch (error) {
      logger.error('Error applying transparency disclaimer:', error);
      
      // Safe fallback - return original text with signature
      const fallbackDisclaimer = this.defaultSignature[language] || this.defaultSignature.es;
      return {
        finalText: roastText + '\n\n' + fallbackDisclaimer,
        transparencyMode: 'signature',
        disclaimer: fallbackDisclaimer,
        bioText: null
      };
    }
  }

  /**
   * Get bio text for a given language
   * @param {string} language - Language code
   * @returns {string} - Bio text suggestion
   */
  getBioText(language = 'es') {
    return this.defaultBioText[language] || this.defaultBioText.es;
  }

  /**
   * Get transparency mode options for frontend
   * @param {string} language - Language code
   * @returns {Array<Object>} - Array of transparency options
   */
  getTransparencyOptions(language = 'es') {
    const labels = {
      es: {
        bio: {
          label: 'Aviso en Bio',
          description: 'A√±ade el aviso manualmente en tu biograf√≠a'
        },
        signature: {
          label: 'Firma cl√°sica',
          description: 'Cada roast termina con "‚Äî Generado por Roastr.AI"'
        },
        creative: {
          label: 'Disclaimers creativos',
          description: 'Disclaimers aleatorios y divertidos en cada roast'
        }
      },
      en: {
        bio: {
          label: 'Bio Notice',
          description: 'Manually add the notice to your bio'
        },
        signature: {
          label: 'Classic Signature',
          description: 'Each roast ends with "‚Äî Generated by Roastr.AI"'
        },
        creative: {
          label: 'Creative Disclaimers',
          description: 'Random and fun disclaimers in each roast'
        }
      }
    };

    const lang = labels[language] || labels.es;

    return [
      {
        value: 'bio',
        label: lang.bio.label,
        description: lang.bio.description,
        is_default: true
      },
      {
        value: 'signature',
        label: lang.signature.label,
        description: lang.signature.description
      },
      {
        value: 'creative',
        label: lang.creative.label,
        description: lang.creative.description
      }
    ];
  }

  /**
   * Update disclaimer usage statistics (for analytics)
   * @param {string} disclaimerText - The disclaimer that was used
   * @param {string} language - Language code
   */
  async updateDisclaimerStats(disclaimerText, language = 'es') {
    try {
      if (!flags.isEnabled('ENABLE_SUPABASE') || !disclaimerText) {
        return;
      }

      // Update usage count in database
      await supabaseServiceClient
        .from('transparency_disclaimers')
        .update({ 
          usage_count: supabaseServiceClient.rpc('increment_usage_count'),
          last_used_at: new Date().toISOString()
        })
        .eq('disclaimer_text', disclaimerText)
        .eq('language', language);

    } catch (error) {
      // Non-critical error, just log it
      logger.warn('Failed to update disclaimer stats:', error);
    }
  }
}

module.exports = new TransparencyService();