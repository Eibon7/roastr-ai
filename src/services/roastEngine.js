/**
 * Advanced Roast Engine (SPEC 7 - Issue #363)
 * 
 * Implements the comprehensive roast generation system with:
 * - 1-2 version generation (controlled by flag)
 * - Predefined voice styles (ES: Flanders, Balanceado, Canalla / EN: Light, Balanced, Savage)
 * - Auto-approve logic with mandatory transparency validation
 * - Only metadata persistence (GDPR compliant)
 * - Retry logic (up to 3 attempts)
 * - Creative transparency disclaimer pool
 */

const { logger } = require('../utils/logger');
const { flags } = require('../config/flags');
const { supabaseServiceClient } = require('../config/supabase');
const RoastGeneratorEnhanced = require('./roastGeneratorEnhanced');
const transparencyService = require('./transparencyService');
const { VALIDATION_CONSTANTS, isValidStyle } = require('../config/validationConstants');

class RoastEngine {
    constructor() {
        this.roastGenerator = new RoastGeneratorEnhanced();
        
        // Predefined voice styles according to spec
        this.voiceStyles = {
            es: {
                'flanders': {
                    name: 'Flanders',
                    description: 'Tono amable pero con iron√≠a sutil',
                    intensity: 2,
                    characteristics: 'educado, ir√≥nico, elegante'
                },
                'balanceado': {
                    name: 'Balanceado', 
                    description: 'Equilibrio entre ingenio y firmeza',
                    intensity: 3,
                    characteristics: 'equilibrado, ingenioso, directo'
                },
                'canalla': {
                    name: 'Canalla',
                    description: 'Directo y sin filtros, m√°s picante',
                    intensity: 4,
                    characteristics: 'directo, sin filtros, contundente'
                }
            },
            en: {
                'light': {
                    name: 'Light',
                    description: 'Gentle wit with subtle irony',
                    intensity: 2,
                    characteristics: 'polite, witty, sophisticated'
                },
                'balanced': {
                    name: 'Balanced',
                    description: 'Perfect mix of humor and firmness',
                    intensity: 3,
                    characteristics: 'balanced, clever, straightforward'
                },
                'savage': {
                    name: 'Savage',
                    description: 'Direct and unfiltered, maximum impact',
                    intensity: 4,
                    characteristics: 'direct, unfiltered, impactful'
                }
            }
        };

        // Creative transparency disclaimer pool for auto-approve mode
        this.transparencyDisclaimers = {
            es: [
                "Cortes√≠a de tu asistente personal anti-trolls ‚ú®",
                "Mensaje autom√°tico: troll detectado y neutralizado üéØ",
                "Tu IA personal se encarga de los molestos ü§ñ",
                "Auto-respuesta inteligente: problema resuelto üõ°Ô∏è",
                "Generado autom√°ticamente por tu escudo digital üî•"
            ],
            en: [
                "Courtesy of your personal anti-troll assistant ‚ú®",
                "Auto-response: troll detected and neutralized üéØ", 
                "Your AI personal assistant handles the annoying ones ü§ñ",
                "Smart auto-reply: problem solved üõ°Ô∏è",
                "Auto-generated by your digital shield üî•"
            ]
        };
    }

    /**
     * Main entry point for roast generation (SPEC 7 requirement)
     * @param {Object} input - Comment and generation configuration
     * @param {Object} options - Generation options including auto-approve settings
     * @returns {Promise<Object>} - Generated roast(s) with metadata
     */
    async generateRoast(input, options = {}) {
        const startTime = Date.now();
        const maxRetries = 3;

        try {
            logger.info('üî• Starting roast generation with engine', {
                userId: options.userId,
                autoApprove: options.autoApprove,
                style: options.style,
                language: options.language || 'es'
            });

            // Get roast versions flag (2 ‚Üí 1 version control)
            const versionsToGenerate = flags.isEnabled('ROAST_VERSIONS_MULTIPLE') ? 2 : 1;
            
            // Validate input
            this.validateInput(input, options);

            // Get user plan and configuration
            const userConfig = await this.getUserConfiguration(options.userId);
            
            // Attempt generation with retry logic
            let result = null;
            let lastError = null;

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    logger.info(`üîÑ Roast generation attempt ${attempt}/${maxRetries}`);
                    
                    result = await this.performGeneration(input, options, userConfig, versionsToGenerate);
                    
                    // If we get here, generation succeeded
                    break;
                } catch (error) {
                    lastError = error;
                    logger.warn(`‚ùå Generation attempt ${attempt} failed`, {
                        attempt,
                        error: error.message,
                        userId: options.userId
                    });

                    // If this was the last attempt, we'll throw after the loop
                    if (attempt === maxRetries) {
                        break;
                    }

                    // Brief delay before retry
                    await new Promise(resolve => setTimeout(resolve, 500 * attempt));
                }
            }

            // If all retries failed, throw the last error
            if (!result) {
                throw new Error(`Roast generation failed after ${maxRetries} attempts: ${lastError?.message || 'Unknown error'}`);
            }

            // Handle auto-approve logic
            if (options.autoApprove) {
                result = await this.handleAutoApprove(result, options);
            } else {
                result.status = 'pending';
                result.requiresApproval = true;
            }

            // Persist metadata only (GDPR compliance)
            const metadata = await this.persistMetadata(result, input, options);
            
            const processingTime = Date.now() - startTime;

            logger.info('‚úÖ Roast generation completed successfully', {
                userId: options.userId,
                versionsGenerated: result.versions?.length || 1,
                autoApprove: options.autoApprove,
                status: result.status,
                processingTimeMs: processingTime
            });

            return {
                success: true,
                ...result,
                metadata: {
                    ...metadata,
                    processingTimeMs: processingTime,
                    versionsGenerated: versionsToGenerate,
                    generatedAt: new Date().toISOString()
                }
            };

        } catch (error) {
            const processingTime = Date.now() - startTime;
            
            logger.error('‚ùå Roast generation failed completely', {
                userId: options.userId,
                error: error.message,
                stack: error.stack,
                processingTimeMs: processingTime
            });

            // Return clear error to user
            return {
                success: false,
                error: 'No pudimos generar el roast en este momento',
                details: process.env.NODE_ENV === 'development' ? error.message : undefined,
                retries: maxRetries,
                processingTimeMs: processingTime
            };
        }
    }

    /**
     * Validate input parameters
     */
    validateInput(input, options) {
        if (!input || !input.comment) {
            throw new Error('Input comment is required');
        }

        if (!options.userId) {
            throw new Error('User ID is required');
        }

        if (input.comment.length > VALIDATION_CONSTANTS.MAX_COMMENT_LENGTH) {
            throw new Error(`Comment exceeds maximum length of ${VALIDATION_CONSTANTS.MAX_COMMENT_LENGTH} characters`);
        }

        if (options.style && !isValidStyle(options.style, options.language || 'es')) {
            throw new Error(`Invalid style: ${options.style}`);
        }
    }


    /**
     * Get user configuration from database
     */
    async getUserConfiguration(userId) {
        try {
            const { data, error } = await supabaseServiceClient
                .rpc('get_user_roast_config', { user_uuid: userId });

            if (error) {
                logger.error('Error fetching user roast config:', error);
                return this.getDefaultConfiguration();
            }

            if (!data || data.length === 0) {
                return this.getDefaultConfiguration();
            }

            // Normalize database response from snake_case to camelCase with nullish coalescing
            const config = data[0];
            return {
                plan: config.plan ?? 'starter_trial',
                autoApprove: config.auto_approve ?? false,
                defaultStyle: config.default_style ?? 'balanceado',
                language: config.language ?? 'es',
                transparencyMode: config.transparency_mode ?? 'signature',
                userId
            };
        } catch (error) {
            logger.error('Exception fetching user roast config:', error);
            return this.getDefaultConfiguration();
        }
    }

    /**
     * Get default configuration for users without custom settings
     */
    getDefaultConfiguration() {
        return {
            plan: 'starter_trial',
            autoApprove: false,
            defaultStyle: 'balanceado',
            language: 'es',
            transparencyMode: 'signature',
            userId: null
        };
    }

    /**
     * Perform the actual roast generation
     */
    async performGeneration(input, options, userConfig, versionsToGenerate) {
        const language = options.language || userConfig.language || 'es';
        const style = options.style || userConfig.defaultStyle || 'balanceado';
        
        // Get style configuration
        const styleConfig = this.getStyleConfiguration(style, language);
        
        // Enhanced generation configuration
        const generationConfig = {
            userId: options.userId,
            plan: userConfig.plan,
            tone: this.mapStyleToTone(style),
            // humor_type removed (Issue #868)
            // intensity_level removed (Issue #868)
            language: language,
            preview_mode: false,
            style: style,
            styleConfig: styleConfig
        };

        if (versionsToGenerate === 1) {
            // Generate single version
            const roastResult = await this.roastGenerator.generateRoast(
                input.comment,
                input.toxicityScore || 0.5,
                generationConfig.tone,
                generationConfig
            );

            return {
                roast: roastResult.roast,
                versions: [
                    {
                        id: 1,
                        text: roastResult.roast,
                        style: style,
                        styleConfig: styleConfig
                    }
                ],
                tokensUsed: roastResult.tokensUsed,
                method: roastResult.method,
                style: style,
                language: language
            };
        } else {
            // Generate multiple versions (2) in parallel for better performance
            logger.info('üîÑ Generating 2 roast versions in parallel');
            
            // Create generation promises for parallel execution
            const versionPromises = [1, 2].map(async (versionNumber) => {
                const versionConfig = {
                    ...generationConfig,
                    temperature: versionNumber === 1 ? 0.8 : 0.9, // Slightly different creativity
                    versionNumber: versionNumber
                };

                const roastResult = await this.roastGenerator.generateRoast(
                    input.comment,
                    input.toxicityScore || 0.5,
                    generationConfig.tone,
                    versionConfig
                );

                return {
                    id: versionNumber,
                    text: roastResult.roast,
                    style: style,
                    styleConfig: styleConfig,
                    tokensUsed: roastResult.tokensUsed || 0
                };
            });

            // Wait for all versions to complete
            const versions = await Promise.all(versionPromises);
            const totalTokens = versions.reduce((sum, version) => sum + version.tokensUsed, 0);

            return {
                roast: versions[0].text, // Primary version
                versions: versions,
                tokensUsed: totalTokens,
                method: 'multi_version',
                style: style,
                language: language
            };
        }
    }

    /**
     * Get style configuration for given style and language
     */
    getStyleConfiguration(style, language) {
        const styles = this.voiceStyles[language] || this.voiceStyles.es;
        return styles[style] || styles.balanceado || styles.balanced;
    }

    /**
     * Map style to tone for compatibility with existing generator
     */
    mapStyleToTone(style) {
        const toneMap = {
            'flanders': 'subtle',
            'light': 'subtle',
            'balanceado': 'sarcastic',
            'balanced': 'sarcastic',
            'canalla': 'direct',
            'savage': 'direct'
        };
        return toneMap[style] || 'sarcastic';
    }

    /**
     * Handle auto-approve logic with mandatory transparency validation
     */
    async handleAutoApprove(result, options) {
        const language = options.language || 'es';
        
        try {
            logger.info('üîç Processing auto-approve with transparency validation');

            // Apply creative transparency disclaimer from pool
            const disclaimerResult = await this.applyCreativeTransparency(result, language);
            
            // Validate transparency was properly applied
            const transparencyValidation = this.validateTransparency(disclaimerResult);
            
            if (!transparencyValidation.isValid) {
                // Block publication if transparency validation fails
                logger.error('‚ùå Transparency validation failed - blocking publication', {
                    reason: transparencyValidation.reason,
                    userId: options.userId
                });

                // Log error to Sentry (in production)
                if (process.env.NODE_ENV === 'production') {
                    // Check if Sentry is available
                    try {
                        if (typeof window !== 'undefined' && window.Sentry) {
                            window.Sentry.captureMessage('Transparency validation failed', {
                                level: 'error',
                                extra: {
                                    userId: options.userId,
                                    reason: transparencyValidation.reason
                                }
                            });
                        } else if (typeof global !== 'undefined' && global.Sentry) {
                            global.Sentry.captureMessage('Transparency validation failed', {
                                level: 'error',
                                extra: {
                                    userId: options.userId,
                                    reason: transparencyValidation.reason
                                }
                            });
                        } else {
                            // Fallback logging for production
                            console.error('SENTRY_LOG: Transparency validation failed', {
                                userId: options.userId,
                                reason: transparencyValidation.reason
                            });
                        }
                    } catch (sentryError) {
                        console.error('Failed to log to Sentry:', sentryError);
                    }
                }

                throw new Error(`Transparency validation failed: ${transparencyValidation.reason}`);
            }

            // Update result with transparency-enhanced content
            result.roast = disclaimerResult.enhancedText;
            result.versions = result.versions?.map(version => ({
                ...version,
                text: disclaimerResult.enhancedText,
                hasTransparency: true
            }));

            result.status = 'auto_approved';
            result.transparency = {
                applied: true,
                method: 'creative_pool',
                disclaimer: disclaimerResult.disclaimer,
                validated: true
            };

            logger.info('‚úÖ Auto-approve completed with transparency validation', {
                userId: options.userId,
                transparencyMethod: 'creative_pool'
            });

            return result;

        } catch (error) {
            logger.error('‚ùå Auto-approve failed', {
                userId: options.userId,
                error: error.message
            });

            // Fallback to pending status if auto-approve fails
            result.status = 'pending';
            result.transparency = {
                applied: false,
                error: error.message
            };
            result.requiresApproval = true;

            return result;
        }
    }

    /**
     * Apply creative transparency disclaimer from predefined pool
     */
    async applyCreativeTransparency(result, language) {
        const disclaimers = this.transparencyDisclaimers[language] || this.transparencyDisclaimers.es;
        
        // Randomly select disclaimer to avoid repetition
        const selectedDisclaimer = disclaimers[Math.floor(Math.random() * disclaimers.length)];
        
        // Integrate disclaimer naturally into the roast
        const enhancedText = `${result.roast}\n\n${selectedDisclaimer}`;
        
        return {
            enhancedText,
            disclaimer: selectedDisclaimer,
            method: 'creative_pool'
        };
    }

    /**
     * Validate that transparency disclaimer was properly applied
     */
    validateTransparency(disclaimerResult) {
        if (!disclaimerResult.enhancedText) {
            return {
                isValid: false,
                reason: 'No enhanced text found'
            };
        }

        if (!disclaimerResult.disclaimer) {
            return {
                isValid: false,
                reason: 'No disclaimer applied'
            };
        }

        if (!disclaimerResult.enhancedText.includes(disclaimerResult.disclaimer)) {
            return {
                isValid: false,
                reason: 'Disclaimer not properly integrated into text'
            };
        }

        return {
            isValid: true,
            reason: 'Transparency validation passed'
        };
    }

    /**
     * Persist only metadata to database (GDPR compliant)
     */
    async persistMetadata(result, input, options) {
        try {
            const metadata = {
                id: `roast_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                userId: options.userId,
                orgId: options.orgId,
                platform: options.platform || 'unknown',
                commentId: input.commentId,
                style: result.style,
                language: result.language,
                versionsCount: result.versions?.length || 1,
                autoApprove: options.autoApprove,
                transparencyApplied: result.transparency?.applied || false,
                status: result.status,
                tokensUsed: result.tokensUsed,
                method: result.method,
                createdAt: new Date().toISOString()
            };

            // Store metadata in database (normalize field names)
            const dbMetadata = {
                id: metadata.id,
                user_id: metadata.userId,
                org_id: metadata.orgId,
                platform: metadata.platform,
                comment_id: metadata.commentId,
                style: metadata.style,
                language: metadata.language,
                versions_count: metadata.versionsCount,
                auto_approve: metadata.autoApprove,
                transparency_applied: metadata.transparencyApplied,
                status: metadata.status,
                tokens_used: metadata.tokensUsed,
                method: metadata.method,
                created_at: metadata.createdAt
            };

            const { error } = await supabaseServiceClient
                .from('roasts_metadata')
                .insert(dbMetadata);

            if (error) {
                logger.error('Error persisting roast metadata:', error);
            } else {
                logger.info('‚úÖ Roast metadata persisted successfully', {
                    id: metadata.id,
                    userId: options.userId
                });
            }

            return metadata;

        } catch (error) {
            logger.error('Exception persisting roast metadata:', error);
            return {
                id: 'error',
                error: error.message
            };
        }
    }

    /**
     * Get available voice styles for a language
     */
    getAvailableStyles(language = 'es') {
        return this.voiceStyles[language] || this.voiceStyles.es;
    }

    /**
     * Get creative transparency disclaimers for a language
     */
    getTransparencyDisclaimers(language = 'es') {
        return this.transparencyDisclaimers[language] || this.transparencyDisclaimers.es;
    }
}

module.exports = RoastEngine;