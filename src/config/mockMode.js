/**
 * Central Mock Mode Configuration
 * 
 * Controls whether the application uses real APIs or mock responses
 * Switch: ENABLE_MOCK_MODE=true/false
 */

class MockModeManager {
  constructor() {
    this.isMockMode = this.shouldUseMockMode();
    this.logMockStatus();
  }

  shouldUseMockMode() {
    // Force mock mode in test environment
    if (process.env.NODE_ENV === 'test') {
      return true;
    }
    
    // Check explicit mock mode setting
    if (process.env.ENABLE_MOCK_MODE === 'true') {
      return true;
    }
    
    // Auto-detect mock mode if critical keys are missing
    const criticalKeys = [
      'OPENAI_API_KEY',
      'SUPABASE_URL', 
      'SUPABASE_SERVICE_KEY'
    ];
    
    const missingKeys = criticalKeys.filter(key => !process.env[key] || process.env[key].startsWith('mock'));
    
    return missingKeys.length > 0;
  }

  logMockStatus() {
    if (this.isMockMode) {
      console.log('ðŸŽ­ Mock Mode ENABLED - Using fake data for all external APIs');
    } else {
      console.log('ðŸ”— Real Mode ENABLED - Using real API connections');
    }
  }

  // API Mock Generators
  generateMockSupabaseClient() {
    return {
      auth: {
        signInWithPassword: () => Promise.resolve({
          data: { user: { id: 'mock-user-123', email: 'test@example.com' } },
          error: null
        }),
        signUp: () => Promise.resolve({
          data: { user: { id: 'mock-user-123', email: 'test@example.com' } },
          error: null
        }),
        signOut: () => Promise.resolve({ error: null }),
        getUser: () => Promise.resolve({
          data: { user: { id: 'mock-user-123', email: 'test@example.com' } },
          error: null
        }),
        onAuthStateChange: (callback) => {
          callback('SIGNED_IN', { id: 'mock-user-123', email: 'test@example.com' });
          return { data: { subscription: { unsubscribe: () => {} } } };
        }
      },
      from: (table) => ({
        select: () => ({
          eq: () => Promise.resolve({
            data: [{ id: 1, name: 'Mock Data', created_at: new Date().toISOString() }],
            error: null
          })
        }),
        insert: () => Promise.resolve({
          data: [{ id: 1, name: 'Mock Insert', created_at: new Date().toISOString() }],
          error: null
        }),
        update: () => ({
          eq: () => Promise.resolve({
            data: [{ id: 1, name: 'Mock Update', updated_at: new Date().toISOString() }],
            error: null
          })
        }),
        delete: () => ({
          eq: () => Promise.resolve({ data: null, error: null })
        })
      })
    };
  }

  generateMockOpenAI() {
    return {
      chat: {
        completions: {
          create: async (params) => ({
            choices: [
              {
                message: {
                  content: "ðŸŽ­ This is a mock roast response! In real mode, this would be a witty comeback generated by OpenAI."
                }
              }
            ],
            usage: {
              prompt_tokens: 50,
              completion_tokens: 20,
              total_tokens: 70
            }
          })
        }
      }
    };
  }

  generateMockStripe() {
    return {
      customers: {
        create: () => Promise.resolve({ id: 'cus_mock123', email: 'test@example.com' }),
        retrieve: () => Promise.resolve({ id: 'cus_mock123', email: 'test@example.com' })
      },
      subscriptions: {
        create: () => Promise.resolve({ id: 'sub_mock123', status: 'active' }),
        retrieve: () => Promise.resolve({ id: 'sub_mock123', status: 'active' })
      },
      prices: {
        list: () => Promise.resolve({
          data: [
            { id: 'price_mock_basic', unit_amount: 999, nickname: 'Basic Plan' },
            { id: 'price_mock_pro', unit_amount: 2999, nickname: 'Pro Plan' }
          ]
        })
      },
      webhooks: {
        constructEvent: () => ({ type: 'invoice.payment_succeeded', data: { object: {} } })
      }
    };
  }

  generateMockPerspective() {
    return {
      comments: {
        analyze: () => Promise.resolve({
          data: {
            attributeScores: {
              TOXICITY: { summaryScore: { value: 0.1 } },
              SEVERE_TOXICITY: { summaryScore: { value: 0.05 } },
              IDENTITY_ATTACK: { summaryScore: { value: 0.03 } }
            }
          }
        })
      }
    };
  }

  generateMockFetch() {
    return async (url, options = {}) => {
      console.log(`ðŸŽ­ Mock fetch called: ${url}`);
      
      // Mock different API responses based on URL
      if (url.includes('/api/health')) {
        return {
          ok: true,
          status: 200,
          json: () => Promise.resolve({
            status: 'ok',
            timestamp: new Date().toISOString(),
            services: {
              database: 'mock',
              queue: 'mock', 
              ai: 'mock'
            }
          })
        };
      }
      
      if (url.includes('/api/logs')) {
        return {
          ok: true,
          status: 200,
          json: () => Promise.resolve({
            logs: [
              { id: 1, level: 'info', message: 'Mock log entry', timestamp: new Date().toISOString() },
              { id: 2, level: 'warn', message: 'Mock warning', timestamp: new Date().toISOString() }
            ],
            total: 2
          })
        };
      }

      if (url.includes('supabase')) {
        return {
          ok: true,
          status: 200,
          json: () => Promise.resolve({ mock: true, data: [] })
        };
      }

      // Default mock response
      return {
        ok: true,
        status: 200,
        json: () => Promise.resolve({ mock: true, message: 'Mock API response' }),
        text: () => Promise.resolve('Mock response text')
      };
    };
  }
}

// Singleton instance
const mockMode = new MockModeManager();

module.exports = {
  mockMode,
  MockModeManager
};