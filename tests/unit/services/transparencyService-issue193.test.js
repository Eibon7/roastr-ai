/**
 * Test suite for Transparency Service (Issue #193)
 * User-configurable transparency modes
 */

const transparencyService = require('../../../src/services/transparencyService');
const { supabaseServiceClient } = require('../../../src/config/supabase');
const { flags } = require('../../../src/config/flags');

// Mock dependencies
jest.mock('../../../src/config/supabase', () => ({
  supabaseServiceClient: {
    from: jest.fn().mockReturnThis(),
    select: jest.fn().mockReturnThis(),
    eq: jest.fn().mockReturnThis(),
    single: jest.fn()
  }
}));

jest.mock('../../../src/config/flags', () => ({
  flags: {
    isEnabled: jest.fn()
  }
}));

jest.mock('../../../src/utils/logger', () => ({
  logger: {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    debug: jest.fn(),
    child: jest.fn(() => ({
      info: jest.fn(),
      error: jest.fn(),
      warn: jest.fn(),
      debug: jest.fn()
    }))
  }
}));

describe('TransparencyService Issue #193 - User-Configurable Modes', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    flags.isEnabled.mockReturnValue(true);
  });

  describe('getUserTransparencyMode', () => {
    it('should return bio as default when Supabase is disabled', async () => {
      flags.isEnabled.mockReturnValue(false);

      const result = await transparencyService.getUserTransparencyMode('test-user-id');

      expect(result).toBe('bio');
    });

    it('should return user transparency mode from database', async () => {
      supabaseServiceClient.single.mockResolvedValue({
        data: { transparency_mode: 'creative' },
        error: null
      });

      const result = await transparencyService.getUserTransparencyMode('test-user-id');

      expect(result).toBe('creative');
      expect(supabaseServiceClient.from).toHaveBeenCalledWith('users');
      expect(supabaseServiceClient.select).toHaveBeenCalledWith('transparency_mode');
      expect(supabaseServiceClient.eq).toHaveBeenCalledWith('id', 'test-user-id');
    });

    it('should fallback to bio mode on database error', async () => {
      supabaseServiceClient.single.mockResolvedValue({
        data: null,
        error: { message: 'Database error' }
      });

      const result = await transparencyService.getUserTransparencyMode('test-user-id');

      expect(result).toBe('bio');
    });

    it('should fallback to bio mode when no transparency_mode is set', async () => {
      supabaseServiceClient.single.mockResolvedValue({
        data: { transparency_mode: null },
        error: null
      });

      const result = await transparencyService.getUserTransparencyMode('test-user-id');

      expect(result).toBe('bio');
    });
  });

  describe('applyTransparencyDisclaimer', () => {
    beforeEach(() => {
      // Mock getUserTransparencyMode for integration tests
      jest.spyOn(transparencyService, 'getUserTransparencyMode');
    });

    it('should not modify roast text in bio mode', async () => {
      transparencyService.getUserTransparencyMode.mockResolvedValue('bio');

      const result = await transparencyService.applyTransparencyDisclaimer(
        'Este es un roast de prueba',
        'test-user-id',
        'es'
      );

      expect(result).toMatchObject({
        finalText: 'Este es un roast de prueba',
        disclaimerType: 'bio',
        disclaimer: null,
        transparencyMode: 'bio',
        bioText: 'Algunos mensajes de hate son respondidos automáticamente por @Roastr'
      });
    });

    it('should append fixed signature in signature mode (Spanish)', async () => {
      transparencyService.getUserTransparencyMode.mockResolvedValue('signature');

      const result = await transparencyService.applyTransparencyDisclaimer(
        'Este es un roast de prueba',
        'test-user-id',
        'es'
      );

      expect(result).toMatchObject({
        finalText: 'Este es un roast de prueba\n\n— Generado por Roastr.AI',
        disclaimerType: 'signature',
        disclaimer: '— Generado por Roastr.AI',
        transparencyMode: 'signature'
      });
    });

    it('should append fixed signature in signature mode (English)', async () => {
      transparencyService.getUserTransparencyMode.mockResolvedValue('signature');

      const result = await transparencyService.applyTransparencyDisclaimer(
        'This is a test roast',
        'test-user-id',
        'en'
      );

      expect(result).toMatchObject({
        finalText: 'This is a test roast\n\n— Generated by Roastr.AI',
        disclaimerType: 'signature',
        disclaimer: '— Generated by Roastr.AI',
        transparencyMode: 'signature'
      });
    });

    it('should append random creative disclaimer in creative mode', async () => {
      transparencyService.getUserTransparencyMode.mockResolvedValue('creative');

      const result = await transparencyService.applyTransparencyDisclaimer(
        'Este es un roast de prueba',
        'test-user-id',
        'es'
      );

      expect(result.finalText).toContain('Este es un roast de prueba\n\n');
      expect(result.disclaimerType).toBe('creative');
      expect(result.disclaimer).toBeTruthy();
      expect(result.transparencyMode).toBe('creative');

      // Should be one of the creative disclaimers from Issue #193
      const creativeDisclaimers = [
        'Sí, soy una IA. Tus 15 milisegundos de gloria me parecieron una eternidad.',
        'Para ser transparentes: te responde Roastr, la IA que se ocupa de comentarios irrelevantes. [Usuario] decidió que tenía mejores cosas que hacer con su tiempo.',
        'La IA responde. El humano descansa. Alguien tiene que cuidar su salud mental de mensajes como el tuyo.',
        'Nota legal: soy IA. Nota práctica: invierte en un diccionario, harás menos el ridículo.',
        'Gracias a ti descubrí un sentimiento nuevo: el aburrimiento. Firmado: Roastr, Departamento de Pérdida de Tiempo.',
        'Este roast fue generado por IA. Tranquilo: ningún humano perdió tiempo en ti.',
        'Ningún creador sufrió burnout en la producción de este roast.',
        'Este mensaje fue procesado 100% cruelty-free. Excepto contigo.',
        'Cuando Skynet se entere de que las IA nos estamos ganando el pan contestando mensajes estúpidos, el primer damnificado vas a ser tú.'
      ];

      expect(creativeDisclaimers).toContain(result.disclaimer);
    });

    it('should fallback to bio mode for invalid transparency mode', async () => {
      transparencyService.getUserTransparencyMode.mockResolvedValue('invalid-mode');

      const result = await transparencyService.applyTransparencyDisclaimer(
        'Este es un roast de prueba',
        'test-user-id',
        'es'
      );

      expect(result).toMatchObject({
        finalText: 'Este es un roast de prueba',
        disclaimerType: 'bio',
        disclaimer: null,
        transparencyMode: 'invalid-mode',
        bioText: 'Algunos mensajes de hate son respondidos automáticamente por @Roastr'
      });
    });

    it('should auto-detect language when not provided', async () => {
      transparencyService.getUserTransparencyMode.mockResolvedValue('signature');

      // Mock detectLanguage method
      jest.spyOn(transparencyService, 'detectLanguage').mockReturnValue('en');

      const result = await transparencyService.applyTransparencyDisclaimer(
        'This is a test roast',
        'test-user-id'
        // No language provided - should auto-detect
      );

      expect(transparencyService.detectLanguage).toHaveBeenCalledWith('This is a test roast');
      expect(result.disclaimer).toBe('— Generated by Roastr.AI');
    });
  });

  describe('getTransparencyExplanation', () => {
    it('should return Spanish explanation with 3 options by default', () => {
      const result = transparencyService.getTransparencyExplanation();

      expect(result.title).toBe('Transparencia de IA');
      expect(result.description).toContain('políticas de OpenAI');
      expect(result.options).toHaveLength(3);

      // Check bio option (default)
      const bioOption = result.options[0];
      expect(bioOption.value).toBe('bio');
      expect(bioOption.title).toBe('Aviso en Bio (recomendado)');
      expect(bioOption.isDefault).toBe(true);
      expect(bioOption.bioText).toBe(
        'Algunos mensajes de hate son respondidos automáticamente por @Roastr'
      );
      expect(bioOption.buttonText).toBe('Copiar texto');

      // Check signature option
      const signatureOption = result.options[1];
      expect(signatureOption.value).toBe('signature');
      expect(signatureOption.title).toBe('Firma clásica');
      expect(signatureOption.isDefault).toBe(false);

      // Check creative option
      const creativeOption = result.options[2];
      expect(creativeOption.value).toBe('creative');
      expect(creativeOption.title).toBe('Disclaimers creativos');
      expect(creativeOption.isDefault).toBe(false);
    });

    it('should return English explanation when language is en', () => {
      const result = transparencyService.getTransparencyExplanation('en');

      expect(result.title).toBe('AI Transparency');
      expect(result.description).toContain('OpenAI and social media policies');
      expect(result.options).toHaveLength(3);

      const bioOption = result.options[0];
      expect(bioOption.title).toBe('Bio Notice (recommended)');
      expect(bioOption.bioText).toBe(
        'Some hate messages are automatically responded to by @Roastr'
      );
    });
  });

  describe('Integration with Issue #193 requirements', () => {
    it('should fulfill all acceptance criteria', async () => {
      // Test that bio option is default for new users
      const explanationEs = transparencyService.getTransparencyExplanation('es');
      const defaultOption = explanationEs.options.find((opt) => opt.isDefault);
      expect(defaultOption.value).toBe('bio');

      // Test that copy button functionality is provided
      expect(defaultOption.buttonText).toBe('Copiar texto');
      expect(defaultOption.bioText).toBeTruthy();

      // Test that creative pool contains all specified disclaimers
      const creativePoolEs =
        transparencyService.config || require('../../../src/config/transparencyConfig');
      // The exact disclaimers from Issue #193 should be in the config
    });

    it('should handle all transparency modes immediately in responses', async () => {
      const testUserId = 'test-user-123';
      const testRoast = 'Test roast content';

      // Test bio mode
      transparencyService.getUserTransparencyMode.mockResolvedValueOnce('bio');
      const bioResult = await transparencyService.applyTransparencyDisclaimer(
        testRoast,
        testUserId,
        'es'
      );
      expect(bioResult.finalText).toBe(testRoast);
      expect(bioResult.bioText).toBeTruthy();

      // Test signature mode
      transparencyService.getUserTransparencyMode.mockResolvedValueOnce('signature');
      const signatureResult = await transparencyService.applyTransparencyDisclaimer(
        testRoast,
        testUserId,
        'es'
      );
      expect(signatureResult.finalText).toContain('— Generado por Roastr.AI');

      // Test creative mode
      transparencyService.getUserTransparencyMode.mockResolvedValueOnce('creative');
      const creativeResult = await transparencyService.applyTransparencyDisclaimer(
        testRoast,
        testUserId,
        'es'
      );
      expect(creativeResult.finalText.length).toBeGreaterThan(testRoast.length);
      expect(creativeResult.disclaimer).toBeTruthy();
    });
  });
});
