const { describe, it, expect, beforeEach } = require('@jest/globals');
const StyleValidator = require('../../../src/services/styleValidator');

describe('StyleValidator - Round 4 CodeRabbit Improvements', () => {
  let validator;

  beforeEach(() => {
    validator = new StyleValidator();
  });

  describe('Disclaimer Pattern Improvements', () => {
    it('should NOT block legitimate hashtags after removing #roastr pattern', () => {
      const legitimateHashtags = [
        'Check out this #roastbeef recipe!',
        'Love this #roast coffee',
        '#roastchicken for dinner tonight',
        'Sunday #roast with the family'
      ];

      legitimateHashtags.forEach(text => {
        const result = validator.validate(text, 'twitter');
        expect(result.valid).toBe(true);
        expect(result.errors).not.toContainEqual(
          expect.objectContaining({
            rule: 'NO_FAKE_DISCLAIMERS'
          })
        );
      });
    });

    it('should still block actual fake Roastr disclaimers', () => {
      const fakeDisclaimers = [
        'Powered by Roastr',
        'Generated by Roastr.AI',
        'Generado por IA - [Roastr]'
        // 'Check out roastr.ai' removed - legitimate URL mention, not a fake disclaimer
      ];

      fakeDisclaimers.forEach(text => {
        const result = validator.validate(text, 'twitter');
        expect(result.valid).toBe(false);
        expect(result.errors).toContainEqual(
          expect.objectContaining({
            rule: 'NO_FAKE_DISCLAIMERS'
          })
        );
      });
    });

    it('should differentiate between hashtag #roastr and disclaimer patterns', () => {
      // Hashtag should be allowed (since we removed the pattern)
      const hashtagText = 'Great #roastr content here!';
      const hashtagResult = validator.validate(hashtagText, 'twitter');
      expect(hashtagResult.valid).toBe(true);

      // But bracketed disclaimers should still be blocked
      const disclaimerText = 'Great content here! [Roastr]';
      const disclaimerResult = validator.validate(disclaimerText, 'twitter');
      expect(disclaimerResult.valid).toBe(false);
    });
  });

  describe('UTF-8 Byte Length Improvements with Buffer.byteLength()', () => {
    it('should calculate UTF-8 byte length using Buffer.byteLength() for ASCII text', () => {
      const asciiText = 'Hello World';
      const result = validator.validate(asciiText, 'twitter');
      
      // ASCII text: each character is 1 byte
      expect(result.metadata.byteLengthUtf8).toBe(11);
      expect(result.metadata.textLength).toBe(11);
    });

    it('should calculate UTF-8 byte length accurately for Unicode characters', () => {
      const unicodeText = 'Hello 世界 🌍'; // ASCII + Chinese + Emoji
      const result = validator.validate(unicodeText, 'twitter');
      
      // Expected UTF-8 bytes: 'Hello ' (6) + '世界' (6) + ' ' (1) + '🌍' (4) = 17
      expect(result.metadata.byteLengthUtf8).toBe(17);
      expect(result.metadata.textLength).toBe(10); // 10 grapheme clusters (actual count)
      expect(result.metadata.codeUnitLength).toBe(11); // 11 UTF-16 code units (actual count)
    });

    it('should handle complex emoji sequences with accurate byte calculation', () => {
      const complexEmoji = '👨‍👩‍👧‍👦'; // Family emoji compound sequence
      const result = validator.validate(complexEmoji, 'twitter');
      
      // Complex emoji takes multiple bytes but counts as 1 grapheme
      expect(result.metadata.textLength).toBe(1); // 1 grapheme cluster
      expect(result.metadata.byteLengthUtf8).toBeGreaterThan(4); // Multiple UTF-8 bytes
      expect(result.metadata.codeUnitLength).toBeGreaterThan(1); // Multiple UTF-16 code units
    });

    it('should provide accurate byte calculations for mixed content', () => {
      const mixedContent = 'Café naïve résumé 🎉 with émojis and 中文';
      const result = validator.validate(mixedContent, 'twitter');
      
      expect(result.metadata.byteLengthUtf8).toBeGreaterThan(result.metadata.textLength); // Unicode takes more bytes
      expect(result.metadata.byteLengthUtf8).toBeGreaterThan(result.metadata.codeUnitLength); // UTF-8 vs UTF-16
      expect(typeof result.metadata.byteLengthUtf8).toBe('number');
      expect(result.metadata.byteLengthUtf8).toBeGreaterThan(0);
    });

    it('should handle edge cases with Buffer.byteLength() gracefully', () => {
      const edgeCases = [
        '', // Empty string
        '   ', // Whitespace only
        '\n\t\r', // Special characters
        '🏴󠁧󠁢󠁳󠁣󠁴󠁿', // Complex flag emoji
        'null\0undefined' // Null characters
      ];

      edgeCases.forEach(text => {
        const result = validator.validate(text, 'twitter');
        expect(typeof result.metadata.byteLengthUtf8).toBe('number');
        expect(result.metadata.byteLengthUtf8).toBeGreaterThanOrEqual(0);
      });
    });
  });

  describe('Enhanced Error Handling and Fallbacks', () => {
    it('should fallback gracefully if Buffer.byteLength() throws error', () => {
      // Mock Buffer.byteLength to throw an error
      const originalByteLength = Buffer.byteLength;
      Buffer.byteLength = (() => {
        throw new Error('Buffer not available');
      });

      const text = 'Test fallback behavior';
      const result = validator.validate(text, 'twitter');

      expect(result.metadata.byteLengthUtf8).toBeGreaterThan(0); // Should use TextEncoder fallback
      expect(typeof result.metadata.byteLengthUtf8).toBe('number');

      // Restore original function
      Buffer.byteLength = originalByteLength;
    });

    it('should use final fallback if both Buffer and TextEncoder fail', () => {
      // Mock both Buffer.byteLength and TextEncoder
      const originalByteLength = Buffer.byteLength;
      const originalTextEncoder = global.TextEncoder;
      
      Buffer.byteLength = (() => {
        throw new Error('Buffer not available');
      });
      
      global.TextEncoder = undefined;

      const text = 'Test final fallback';
      const result = validator.validate(text, 'twitter');

      // Should use final fallback: text.length * 2
      expect(result.metadata.byteLengthUtf8).toBe(text.length * 2);

      // Restore original functions
      Buffer.byteLength = originalByteLength;
      global.TextEncoder = originalTextEncoder;
    });
  });

  describe('Consistency with Previous Improvements', () => {
    it('should maintain all Round 3 improvements while adding Round 4 enhancements', () => {
      const testText = 'Complex text with 中文, émojis 🎉, and café';
      const result = validator.validate(testText, 'twitter');

      // Round 3 improvements should still work
      expect(result.metadata).toHaveProperty('textLength'); // Grapheme-aware counting
      expect(result.metadata).toHaveProperty('codeUnitLength'); // UTF-16 code units
      expect(result.metadata).toHaveProperty('byteLengthUtf8'); // Round 4: Buffer.byteLength()
      
      // All should be numbers and properly calculated
      expect(typeof result.metadata.textLength).toBe('number');
      expect(typeof result.metadata.codeUnitLength).toBe('number');
      expect(typeof result.metadata.byteLengthUtf8).toBe('number');
      
      // UTF-8 byte length should be >= text length for Unicode content
      expect(result.metadata.byteLengthUtf8).toBeGreaterThanOrEqual(result.metadata.textLength);
    });

    it('should maintain platform normalization (X → twitter) from Round 3', () => {
      const platforms = ['X', 'x', 'x.com', 'twitter'];
      const text = 'Test platform normalization';
      
      const results = platforms.map(platform => validator.validate(text, platform));
      
      // All should have same normalized platform in metadata
      results.forEach(result => {
        expect(result.metadata.platform).toBe('twitter');
      });
    });

    it('should maintain GDPR-compliant logging without text content', () => {
      const sensitiveText = 'This contains personal information';
      
      // Mock logger to capture calls
      const loggerSpy = {
        info: jest.fn(),
        mock: { calls: [] }
      };
      const originalLogger = require('../../../src/utils/logger').logger.info;
      require('../../../src/utils/logger').logger.info = loggerSpy.info;
      
      validator.validate(sensitiveText, 'twitter');
      
      // Verify logger was called but without sensitive text
      expect(loggerSpy.info).toHaveBeenCalled();
      const logCalls = loggerSpy.info.mock.calls;
      logCalls.forEach(call => {
        const logMessage = JSON.stringify(call);
        expect(logMessage).not.toContain('personal information');
        expect(logMessage).not.toContain(sensitiveText);
      });
      
      // Restore original logger
      require('../../../src/utils/logger').logger.info = originalLogger;
    });
  });

  describe('Performance Validation for Round 4 Changes', () => {
    it('should maintain performance with Buffer.byteLength() vs TextEncoder', () => {
      const testTexts = Array.from({ length: 100 }, (_, i) => 
        `Performance test ${i} with émojis 🎉 and Unicode 中文`
      );

      const startTime = Date.now();
      
      testTexts.forEach(text => validator.validate(text, 'twitter'));
      
      const endTime = Date.now();
      const averageTime = (endTime - startTime) / testTexts.length;
      
      // Should complete within reasonable time (improved with Buffer.byteLength)
      expect(averageTime).toBeLessThan(100); // Less than 100ms per validation (CI-friendly)
    });

    it('should not degrade performance after removing hashtag pattern', () => {
      const hashtagTexts = Array.from({ length: 50 }, (_, i) => 
        `Text with #hashtag${i} and #roast${i} and #content${i}`
      );

      const startTime = Date.now();
      
      hashtagTexts.forEach(text => validator.validate(text, 'twitter'));
      
      const endTime = Date.now();
      const totalTime = endTime - startTime;
      
      // Should process quickly without the removed #roastr pattern
      expect(totalTime).toBeLessThan(500); // Under 500ms for 50 validations
    });
  });
});