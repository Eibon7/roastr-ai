const CostControlService = require('../../../src/services/costControl');\nconst { mockMode } = require('../../../src/config/mockMode');\n\n// Mock Supabase\nconst mockSupabase = {\n  from: jest.fn().mockReturnThis(),\n  select: jest.fn().mockReturnThis(),\n  eq: jest.fn().mockReturnThis(),\n  single: jest.fn().mockReturnThis(),\n  insert: jest.fn().mockReturnThis(),\n  update: jest.fn().mockReturnThis(),\n  upsert: jest.fn().mockReturnThis(),\n  rpc: jest.fn().mockReturnThis(),\n  or: jest.fn().mockReturnThis(),\n  order: jest.fn().mockReturnThis(),\n  limit: jest.fn().mockReturnThis(),\n  range: jest.fn().mockReturnThis(),\n  gte: jest.fn().mockReturnThis(),\n  lt: jest.fn().mockReturnThis(),\n  lte: jest.fn().mockReturnThis()\n};\n\njest.mock('@supabase/supabase-js', () => ({\n  createClient: jest.fn(() => mockSupabase)\n}));\n\n// Mock environment variables\nprocess.env.SUPABASE_URL = 'http://localhost:54321';\nprocess.env.SUPABASE_ANON_KEY = 'mock-anon-key';\nprocess.env.ENABLE_MOCK_MODE = 'true';\n\ndescribe('CostControlService - Usage Tracking', () => {\n  let costControl;\n  const mockOrgId = 'org-123-456';\n  const mockUserId = 'user-456-789';\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    costControl = new CostControlService();\n  });\n\n  describe('canPerformOperation', () => {\n    it('should allow operation when within limits', async () => {\n      // Mock database response for operation check\n      mockSupabase.rpc.mockResolvedValueOnce({\n        data: {\n          allowed: true,\n          reason: 'within_limit',\n          current_usage: 50,\n          monthly_limit: 100,\n          remaining: 49,\n          percentage_used: 51\n        },\n        error: null\n      });\n\n      const result = await costControl.canPerformOperation(\n        mockOrgId, \n        'generate_reply', \n        1, \n        'twitter'\n      );\n\n      expect(result.allowed).toBe(true);\n      expect(result.reason).toBe('within_limit');\n      expect(result.current_usage).toBe(50);\n      expect(result.monthly_limit).toBe(100);\n      expect(mockSupabase.rpc).toHaveBeenCalledWith('can_perform_operation', {\n        org_id: mockOrgId,\n        resource_type_param: 'roasts',\n        quantity_param: 1\n      });\n    });\n\n    it('should block operation when limit exceeded', async () => {\n      mockSupabase.rpc.mockResolvedValueOnce({\n        data: {\n          allowed: false,\n          reason: 'monthly_limit_exceeded',\n          current_usage: 100,\n          monthly_limit: 100,\n          remaining: 0\n        },\n        error: null\n      });\n\n      const result = await costControl.canPerformOperation(\n        mockOrgId, \n        'generate_reply'\n      );\n\n      expect(result.allowed).toBe(false);\n      expect(result.reason).toBe('monthly_limit_exceeded');\n      expect(result).toHaveProperty('message');\n      expect(result.message).toContain('Monthly limit of 100 roast responses exceeded');\n    });\n\n    it('should allow overage when configured', async () => {\n      mockSupabase.rpc.mockResolvedValueOnce({\n        data: {\n          allowed: true,\n          reason: 'overage_allowed',\n          current_usage: 105,\n          monthly_limit: 100,\n          overage_amount: 5,\n          will_exceed_limit: true\n        },\n        error: null\n      });\n\n      const result = await costControl.canPerformOperation(\n        mockOrgId, \n        'generate_reply'\n      );\n\n      expect(result.allowed).toBe(true);\n      expect(result.reason).toBe('overage_allowed');\n      expect(result.will_exceed_limit).toBe(true);\n    });\n\n    it('should map operation types to resource types correctly', async () => {\n      mockSupabase.rpc.mockResolvedValueOnce({\n        data: { allowed: true },\n        error: null\n      });\n\n      // Test different operation type mappings\n      await costControl.canPerformOperation(mockOrgId, 'fetch_comment');\n      expect(mockSupabase.rpc).toHaveBeenCalledWith('can_perform_operation', {\n        org_id: mockOrgId,\n        resource_type_param: 'api_calls',\n        quantity_param: 1\n      });\n\n      jest.clearAllMocks();\n      mockSupabase.rpc.mockResolvedValueOnce({\n        data: { allowed: true },\n        error: null\n      });\n\n      await costControl.canPerformOperation(mockOrgId, 'shield_action');\n      expect(mockSupabase.rpc).toHaveBeenCalledWith('can_perform_operation', {\n        org_id: mockOrgId,\n        resource_type_param: 'shield_actions',\n        quantity_param: 1\n      });\n    });\n\n    it('should handle database errors gracefully', async () => {\n      mockSupabase.rpc.mockResolvedValueOnce({\n        data: null,\n        error: new Error('Database connection failed')\n      });\n\n      await expect(costControl.canPerformOperation(mockOrgId, 'generate_reply'))\n        .rejects.toThrow('Database connection failed');\n    });\n  });\n\n  describe('recordUsage', () => {\n    beforeEach(() => {\n      // Mock successful insert for usage_records\n      mockSupabase.insert.mockResolvedValueOnce({\n        data: { id: 'record-123' },\n        error: null\n      });\n      \n      // Mock successful rpc call for enhanced tracking\n      mockSupabase.rpc.mockResolvedValueOnce({\n        data: {\n          recorded: true,\n          resource_type: 'roasts',\n          quantity: 1,\n          current_usage: 51,\n          monthly_limit: 100,\n          limit_exceeded: false,\n          cost_cents: 5\n        },\n        error: null\n      });\n    });\n\n    it('should record usage with enhanced tracking', async () => {\n      const metadata = {\n        commentId: 'comment-123',\n        responseId: 'response-456',\n        tokensUsed: 150,\n        generationTime: 1200,\n        service: 'openai'\n      };\n\n      const result = await costControl.recordUsage(\n        mockOrgId,\n        'twitter',\n        'generate_reply',\n        metadata,\n        mockUserId,\n        1\n      );\n\n      expect(result.recorded).toBe(true);\n      expect(result.cost).toBe(5);\n      expect(result.usageRecordId).toBe('record-123');\n      expect(result.tracking).toHaveProperty('recorded', true);\n\n      // Verify legacy usage_records insert\n      expect(mockSupabase.insert).toHaveBeenCalledWith({\n        organization_id: mockOrgId,\n        platform: 'twitter',\n        action_type: 'generate_reply',\n        tokens_used: 150,\n        cost_cents: 5,\n        metadata: { ...metadata, quantity: 1, resourceType: 'roasts' }\n      });\n\n      // Verify enhanced tracking RPC call\n      expect(mockSupabase.rpc).toHaveBeenCalledWith('record_usage', {\n        org_id: mockOrgId,\n        resource_type_param: 'roasts',\n        platform_param: 'twitter',\n        user_id_param: mockUserId,\n        quantity_param: 1,\n        cost_param: 5,\n        tokens_param: 150,\n        metadata_param: metadata\n      });\n    });\n\n    it('should handle multiple quantities correctly', async () => {\n      mockSupabase.rpc.mockResolvedValueOnce({\n        data: { recorded: true, cost_cents: 15 },\n        error: null\n      });\n\n      const result = await costControl.recordUsage(\n        mockOrgId,\n        'youtube',\n        'fetch_comment',\n        { commentsCount: 3 },\n        null,\n        3\n      );\n\n      expect(result.cost).toBe(0); // fetch_comment has 0 cost per operation\n      expect(mockSupabase.rpc).toHaveBeenCalledWith('record_usage', {\n        org_id: mockOrgId,\n        resource_type_param: 'api_calls',\n        platform_param: 'youtube',\n        user_id_param: null,\n        quantity_param: 3,\n        cost_param: 0,\n        tokens_param: 0,\n        metadata_param: { commentsCount: 3 }\n      });\n    });\n\n    it('should trigger usage alerts when approaching limits', async () => {\n      // Mock tracking result that indicates high usage\n      mockSupabase.rpc.mockResolvedValueOnce({\n        data: {\n          recorded: true,\n          percentage_used: 85,\n          current_usage: 85,\n          monthly_limit: 100\n        },\n        error: null\n      });\n\n      // Mock alert check\n      jest.spyOn(costControl, 'checkAndSendUsageAlerts')\n        .mockResolvedValue(undefined);\n\n      await costControl.recordUsage(\n        mockOrgId,\n        'twitter',\n        'generate_reply',\n        {},\n        null,\n        1\n      );\n\n      expect(costControl.checkAndSendUsageAlerts)\n        .toHaveBeenCalledWith(mockOrgId, 'roasts', expect.any(Object));\n    });\n  });\n\n  describe('setUsageLimit', () => {\n    it('should set usage limits with default options', async () => {\n      mockSupabase.upsert.mockResolvedValueOnce({\n        data: {\n          id: 'limit-123',\n          organization_id: mockOrgId,\n          resource_type: 'roasts',\n          monthly_limit: 500\n        },\n        error: null\n      });\n\n      const result = await costControl.setUsageLimit(\n        mockOrgId,\n        'roasts',\n        500\n      );\n\n      expect(result.monthly_limit).toBe(500);\n      expect(mockSupabase.upsert).toHaveBeenCalledWith(\n        {\n          organization_id: mockOrgId,\n          resource_type: 'roasts',\n          monthly_limit: 500,\n          daily_limit: null,\n          allow_overage: false,\n          overage_rate_cents: 0,\n          hard_limit: true,\n          is_active: true,\n          updated_at: expect.any(String)\n        },\n        { onConflict: 'organization_id,resource_type' }\n      );\n    });\n\n    it('should set usage limits with custom options', async () => {\n      mockSupabase.upsert.mockResolvedValueOnce({\n        data: { id: 'limit-123' },\n        error: null\n      });\n\n      await costControl.setUsageLimit(\n        mockOrgId,\n        'api_calls',\n        1000,\n        {\n          dailyLimit: 50,\n          allowOverage: true,\n          overageRateCents: 2,\n          hardLimit: false\n        }\n      );\n\n      expect(mockSupabase.upsert).toHaveBeenCalledWith(\n        expect.objectContaining({\n          daily_limit: 50,\n          allow_overage: true,\n          overage_rate_cents: 2,\n          hard_limit: false\n        }),\n        { onConflict: 'organization_id,resource_type' }\n      );\n    });\n  });\n\n  describe('updatePlanUsageLimits', () => {\n    beforeEach(() => {\n      jest.spyOn(costControl, 'setUsageLimit').mockResolvedValue({});\n    });\n\n    it('should update limits for free plan', async () => {\n      await costControl.updatePlanUsageLimits(mockOrgId, 'free');\n\n      expect(costControl.setUsageLimit).toHaveBeenCalledWith(\n        mockOrgId, 'roasts', 100, { allowOverage: false, hardLimit: true }\n      );\n      expect(costControl.setUsageLimit).toHaveBeenCalledWith(\n        mockOrgId, 'integrations', 2, { allowOverage: false, hardLimit: true }\n      );\n      expect(costControl.setUsageLimit).toHaveBeenCalledWith(\n        mockOrgId, 'shield_actions', 0, { allowOverage: false, hardLimit: true }\n      );\n    });\n\n    it('should update limits for pro plan', async () => {\n      await costControl.updatePlanUsageLimits(mockOrgId, 'pro');\n\n      expect(costControl.setUsageLimit).toHaveBeenCalledWith(\n        mockOrgId, 'roasts', 1000, { allowOverage: true, hardLimit: false }\n      );\n      expect(costControl.setUsageLimit).toHaveBeenCalledWith(\n        mockOrgId, 'shield_actions', 500, { allowOverage: true, hardLimit: false }\n      );\n    });\n\n    it('should update limits for plus plan', async () => {\n      await costControl.updatePlanUsageLimits(mockOrgId, 'plus');\n\n      expect(costControl.setUsageLimit).toHaveBeenCalledWith(\n        mockOrgId, 'roasts', 5000, { allowOverage: true, hardLimit: false }\n      );\n      expect(costControl.setUsageLimit).toHaveBeenCalledWith(\n        mockOrgId, 'integrations', 999, { allowOverage: true, hardLimit: false }\n      );\n    });\n\n    it('should throw error for invalid plan', async () => {\n      await expect(\n        costControl.updatePlanUsageLimits(mockOrgId, 'invalid_plan')\n      ).rejects.toThrow('Invalid plan: invalid_plan');\n    });\n  });\n\n  describe('getEnhancedUsageStats', () => {\n    beforeEach(() => {\n      const currentDate = new Date();\n      const currentYear = currentDate.getFullYear();\n      const currentMonth = currentDate.getMonth() + 1;\n\n      // Mock current usage data\n      mockSupabase.select.mockResolvedValueOnce({\n        data: [\n          {\n            resource_type: 'roasts',\n            platform: 'twitter',\n            quantity: 45,\n            cost_cents: 225,\n            tokens_used: 4500\n          },\n          {\n            resource_type: 'api_calls',\n            platform: 'youtube',\n            quantity: 20,\n            cost_cents: 0,\n            tokens_used: 0\n          }\n        ],\n        error: null\n      });\n\n      // Mock usage limits\n      mockSupabase.select.mockResolvedValueOnce({\n        data: [\n          {\n            resource_type: 'roasts',\n            monthly_limit: 100,\n            allow_overage: false,\n            hard_limit: true\n          },\n          {\n            resource_type: 'api_calls',\n            monthly_limit: 1000,\n            allow_overage: true,\n            hard_limit: false\n          }\n        ],\n        error: null\n      });\n\n      // Mock organization data\n      mockSupabase.single.mockResolvedValueOnce({\n        data: {\n          plan_id: 'pro',\n          monthly_responses_limit: 1000\n        },\n        error: null\n      });\n    });\n\n    it('should return comprehensive usage statistics', async () => {\n      const result = await costControl.getEnhancedUsageStats(mockOrgId);\n\n      expect(result).toHaveProperty('organizationId', mockOrgId);\n      expect(result).toHaveProperty('planId', 'pro');\n      expect(result.currentMonth).toHaveProperty('usageByResource');\n      expect(result.currentMonth).toHaveProperty('usageByPlatform');\n      \n      // Check roasts resource usage\n      const roastUsage = result.currentMonth.usageByResource.roasts;\n      expect(roastUsage).toEqual({\n        quantity: 45,\n        cost_cents: 225,\n        tokens_used: 4500,\n        platforms: { twitter: 45 },\n        monthly_limit: 100,\n        percentage_used: 45,\n        remaining: 55,\n        limit_exceeded: false,\n        overage_allowed: false\n      });\n\n      // Check platform breakdown\n      expect(result.currentMonth.usageByPlatform).toEqual({\n        twitter: 45,\n        youtube: 20\n      });\n\n      expect(result.currentMonth.totalCostCents).toBe(225);\n      expect(result.currentMonth.totalTokensUsed).toBe(4500);\n    });\n\n    it('should handle database errors', async () => {\n      mockSupabase.select.mockResolvedValueOnce({\n        data: null,\n        error: new Error('Database error')\n      });\n\n      await expect(\n        costControl.getEnhancedUsageStats(mockOrgId)\n      ).rejects.toThrow('Database error');\n    });\n  });\n\n  describe('resetAllMonthlyUsage', () => {\n    it('should reset usage for all organizations', async () => {\n      mockSupabase.rpc.mockResolvedValueOnce({\n        data: 25, // 25 organizations reset\n        error: null\n      });\n\n      const result = await costControl.resetAllMonthlyUsage();\n\n      expect(result.success).toBe(true);\n      expect(result.organizationsReset).toBe(25);\n      expect(result).toHaveProperty('resetAt');\n      expect(mockSupabase.rpc).toHaveBeenCalledWith('reset_monthly_usage');\n    });\n\n    it('should handle reset errors', async () => {\n      mockSupabase.rpc.mockResolvedValueOnce({\n        data: null,\n        error: new Error('Reset failed')\n      });\n\n      await expect(costControl.resetAllMonthlyUsage())\n        .rejects.toThrow('Reset failed');\n    });\n  });\n\n  describe('utility functions', () => {\n    it('should return correct resource display names', () => {\n      expect(costControl.getResourceDisplayName('roasts')).toBe('roast responses');\n      expect(costControl.getResourceDisplayName('api_calls')).toBe('API calls');\n      expect(costControl.getResourceDisplayName('shield_actions')).toBe('shield actions');\n      expect(costControl.getResourceDisplayName('unknown')).toBe('unknown');\n    });\n\n    it('should build appropriate limit messages', () => {\n      const result = {\n        reason: 'monthly_limit_exceeded',\n        current_usage: 100,\n        monthly_limit: 100\n      };\n\n      const message = costControl.buildLimitMessage(result, 'roast responses');\n      expect(message).toContain('Monthly limit of 100 roast responses exceeded');\n      expect(message).toContain('Current usage: 100');\n    });\n\n    it('should handle overage allowed message', () => {\n      const result = { reason: 'overage_allowed' };\n      const message = costControl.buildLimitMessage(result, 'API calls');\n      expect(message).toContain('overage is allowed');\n      expect(message).toContain('Additional charges may apply');\n    });\n  });\n\n  describe('plan configurations', () => {\n    it('should have correct plan configurations', () => {\n      expect(costControl.plans).toHaveProperty('free');\n      expect(costControl.plans).toHaveProperty('pro');\n      expect(costControl.plans).toHaveProperty('plus');\n      expect(costControl.plans).toHaveProperty('custom');\n\n      // Check free plan limits\n      expect(costControl.plans.free.monthlyResponsesLimit).toBe(100);\n      expect(costControl.plans.free.shieldEnabled).toBe(false);\n      expect(costControl.plans.free.integrationsLimit).toBe(2);\n\n      // Check pro plan features\n      expect(costControl.plans.pro.monthlyResponsesLimit).toBe(1000);\n      expect(costControl.plans.pro.shieldEnabled).toBe(true);\n      expect(costControl.plans.pro.integrationsLimit).toBe(5);\n    });\n\n    it('should have correct operation costs', () => {\n      expect(costControl.operationCosts.fetch_comment).toBe(0);\n      expect(costControl.operationCosts.analyze_toxicity).toBe(1);\n      expect(costControl.operationCosts.generate_reply).toBe(5);\n      expect(costControl.operationCosts.post_response).toBe(0);\n    });\n  });\n});"