/**
 * Analytics Endpoint Tests - Issue #366 (CodeRabbit Fixes)
 * Testing the updated analytics summary endpoint with conditional org filtering
 */

const request = require('supertest');
const express = require('express');

// Create a more sophisticated mock chain that properly handles async operations
const createMockQuery = (mockResponse) => {
    const mockChain = {
        from: jest.fn().mockReturnThis(),
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        not: jest.fn().mockReturnThis(),
        // Make the final query result return the mock response
        [Symbol.asyncIterator]: async function* () {
            yield mockResponse;
        }
    };
    
    // Make the final query resolve to mockResponse when awaited
    Object.defineProperty(mockChain, 'then', {
        value: function(resolve, reject) {
            if (mockResponse.error) {
                reject(mockResponse.error);
            } else {
                resolve(mockResponse);
            }
        }
    });
    
    return mockChain;
};

// Mock responses for different scenarios
let mockCommentsResponse = { count: 42, error: null };
let mockResponsesResponse = { count: 24, error: null };

// Mock the Supabase client
const mockSupabaseServiceClient = {
    from: jest.fn((table) => {
        if (table === 'comments') {
            return createMockQuery(mockCommentsResponse);
        } else if (table === 'responses') {
            return createMockQuery(mockResponsesResponse);
        }
        return createMockQuery({ count: 0, error: null });
    })
};

jest.mock('../../../src/config/supabase', () => ({
    supabaseServiceClient: mockSupabaseServiceClient,
    createUserClient: jest.fn()
}));

// Mock authentication middleware
const mockAuthenticateToken = jest.fn((req, res, next) => {
    req.user = { id: 'test-user-id', plan: 'pro', org_id: 'test-org-id' };
    next();
});

jest.mock('../../../src/middleware/auth', () => ({ 
    authenticateToken: mockAuthenticateToken 
}));

describe('Analytics Summary Endpoint - Issue #366 CodeRabbit Fixes', () => {
    let app;

    beforeEach(() => {
        app = express();
        app.use(express.json());
        
        // Reset mock responses
        mockCommentsResponse = { count: 42, error: null };
        mockResponsesResponse = { count: 24, error: null };
        
        // Add the analytics endpoint (matches actual implementation)
        app.get('/api/analytics/summary', mockAuthenticateToken, async (req, res) => {
            try {
                const { supabaseServiceClient } = require('../../../src/config/supabase');
                
                const orgId = req.user?.org_id || null;
                
                // Build query for completed analyses with conditional org filtering
                let commentsQuery = supabaseServiceClient
                    .from('comments')
                    .select('id', { count: 'exact', head: true })
                    .eq('status', 'processed');
                
                // Only apply org filtering when orgId is truthy and valid (Issue #366 CodeRabbit fix)
                if (orgId && orgId !== 'undefined' && orgId !== 'null') {
                    commentsQuery = commentsQuery.eq('organization_id', orgId);
                }
                
                const { count: completedCount, error: analysesError } = await commentsQuery;
                
                if (analysesError) {
                    throw analysesError;
                }

                // Build query for sent roasts with conditional org filtering
                let responsesQuery = supabaseServiceClient
                    .from('responses')
                    .select('id', { count: 'exact', head: true })
                    .not('posted_at', 'is', null);
                
                // Only apply org filtering when orgId is truthy and valid (Issue #366 CodeRabbit fix)
                if (orgId && orgId !== 'undefined' && orgId !== 'null') {
                    responsesQuery = responsesQuery.eq('organization_id', orgId);
                }
                
                const { count: sentCount, error: roastsError } = await responsesQuery;
                
                if (roastsError) {
                    throw roastsError;
                }

                res.json({
                    success: true,
                    data: {
                        completed_analyses: completedCount || 0,
                        sent_roasts: sentCount || 0
                    },
                    meta: {
                        timestamp: new Date().toISOString(),
                        organization_id: (orgId && orgId !== 'undefined' && orgId !== 'null') ? orgId : 'global'
                    }
                });
                
            } catch (error) {
                console.error('Analytics summary error:', error);
                
                res.status(500).json({
                    success: false,
                    error: {
                        message: 'Failed to retrieve analytics summary',
                        details: error.message
                    }
                });
            }
        });
    });

    afterEach(() => {
        jest.clearAllMocks();
    });

    test('should return analytics summary successfully using count property', async () => {
        const response = await request(app)
            .get('/api/analytics/summary')
            .expect(200);

        expect(response.body).toEqual({
            success: true,
            data: {
                completed_analyses: 42,
                sent_roasts: 24
            },
            meta: {
                timestamp: expect.any(String),
                organization_id: 'test-org-id'
            }
        });

        // Verify that from() was called for both tables
        expect(mockSupabaseServiceClient.from).toHaveBeenCalledWith('comments');
        expect(mockSupabaseServiceClient.from).toHaveBeenCalledWith('responses');
    });

    test('should handle database errors gracefully', async () => {
        // Set up error response
        mockCommentsResponse = { count: null, error: new Error('Database connection failed') };

        const response = await request(app)
            .get('/api/analytics/summary')
            .expect(500);

        expect(response.body).toEqual({
            success: false,
            error: {
                message: 'Failed to retrieve analytics summary',
                details: 'Database connection failed'
            }
        });
    });

    test('should return zero values when no data exists', async () => {
        // Set up zero count responses
        mockCommentsResponse = { count: 0, error: null };
        mockResponsesResponse = { count: 0, error: null };

        const response = await request(app)
            .get('/api/analytics/summary')
            .expect(200);

        expect(response.body.data).toEqual({
            completed_analyses: 0,
            sent_roasts: 0
        });
    });

    test('should work for global admin view (no org_id)', async () => {
        // Mock user without org_id
        mockAuthenticateToken.mockImplementationOnce((req, res, next) => {
            req.user = { id: 'admin-user-id', plan: 'admin' };
            next();
        });

        // Set up high count responses for admin view
        mockCommentsResponse = { count: 100, error: null };
        mockResponsesResponse = { count: 50, error: null };

        const response = await request(app)
            .get('/api/analytics/summary')
            .expect(200);

        expect(response.body.data).toEqual({
            completed_analyses: 100,
            sent_roasts: 50
        });

        expect(response.body.meta.organization_id).toBe('global');
    });

    test('should handle null count values gracefully', async () => {
        // Mock null count responses
        mockCommentsResponse = { count: null, error: null };
        mockResponsesResponse = { count: null, error: null };

        const response = await request(app)
            .get('/api/analytics/summary')
            .expect(200);

        expect(response.body.data).toEqual({
            completed_analyses: 0,
            sent_roasts: 0
        });
    });

    test('should not apply org filtering when orgId is "undefined" string', async () => {
        // Mock user with string "undefined" org_id
        mockAuthenticateToken.mockImplementationOnce((req, res, next) => {
            req.user = { id: 'test-user', plan: 'pro', org_id: 'undefined' };
            next();
        });

        const response = await request(app)
            .get('/api/analytics/summary')
            .expect(200);

        expect(response.body.meta.organization_id).toBe('global');
    });

    test('should not apply org filtering when orgId is "null" string', async () => {
        // Mock user with string "null" org_id
        mockAuthenticateToken.mockImplementationOnce((req, res, next) => {
            req.user = { id: 'test-user', plan: 'pro', org_id: 'null' };
            next();
        });

        const response = await request(app)
            .get('/api/analytics/summary')
            .expect(200);

        expect(response.body.meta.organization_id).toBe('global');
    });
});

describe('Feature Flags Integration - Issue #366', () => {
    test('should have SHOP_ENABLED flag configured', () => {
        process.env.SHOP_ENABLED = 'true';
        
        // Mock flags module
        const parseFlag = (value, defaultValue = false) => {
            if (value === undefined || value === null) return defaultValue;
            if (typeof value === 'boolean') return value;
            return value.toLowerCase() === 'true';
        };
        
        const shopEnabled = parseFlag(process.env.SHOP_ENABLED, false);
        expect(shopEnabled).toBe(true);
        
        process.env.SHOP_ENABLED = 'false';
        const shopDisabled = parseFlag(process.env.SHOP_ENABLED, false);
        expect(shopDisabled).toBe(false);
    });

    test('should have ENABLE_SHIELD_UI flag configured', () => {
        process.env.ENABLE_SHIELD_UI = 'true';
        
        const parseFlag = (value, defaultValue = false) => {
            if (value === undefined || value === null) return defaultValue;
            if (typeof value === 'boolean') return value;
            return value.toLowerCase() === 'true';
        };
        
        const shieldUIEnabled = parseFlag(process.env.ENABLE_SHIELD_UI, false);
        expect(shieldUIEnabled).toBe(true);
        
        process.env.ENABLE_SHIELD_UI = 'false';
        const shieldUIDisabled = parseFlag(process.env.ENABLE_SHIELD_UI, false);
        expect(shieldUIDisabled).toBe(false);
    });
});

describe('GDPR Transparency Text - Issue #366', () => {
    test('should contain required transparency text', () => {
        const transparencyText = 'Los roasts autopublicados llevan firma de IA para cumplir con la normativa de transparencia digital.';
        
        expect(transparencyText).toContain('Los roasts autopublicados llevan firma de IA');
        expect(transparencyText).toContain('transparencia digital');
    });

    test('should provide GDPR compliance information', () => {
        const gdprText = 'De acuerdo con el RGPD y las normativas de transparencia digital, todos los contenidos generados automáticamente por IA incluyen marcadores identificativos apropiados.';
        
        expect(gdprText).toContain('RGPD');
        expect(gdprText).toContain('contenidos generados automáticamente por IA');
        expect(gdprText).toContain('marcadores identificativos');
    });
});