/**
 * Integration tests for notification endpoints with rate limiting
 * Issue #97: Implement rate limiting for notification endpoints
 */

const request = require('supertest');
const express = require('express');

// Mock dependencies
jest.mock('../../../src/utils/logger', () => ({
    logger: {
        warn: jest.fn(),
        info: jest.fn(),
        error: jest.fn()
    }
}));

jest.mock('../../../src/config/flags', () => ({
    flags: {
        isEnabled: jest.fn((flag) => {
            if (flag === 'DISABLE_RATE_LIMIT') return false;
            return false;
        })
    }
}));

jest.mock('../../../src/services/notificationService', () => ({
    getUserNotifications: jest.fn(),
    getUnreadCount: jest.fn(),
    markAsRead: jest.fn(),
    markAllAsRead: jest.fn()
}));

jest.mock('../../../src/config/supabase', () => ({
    supabaseServiceClient: {
        from: jest.fn().mockReturnThis(),
        update: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        select: jest.fn().mockReturnThis(),
        single: jest.fn()
    }
}));

jest.mock('../../../src/middleware/auth', () => ({
    authenticateToken: (req, res, next) => {
        req.user = { id: 'test-user-123' };
        next();
    }
}));

describe('Notification Routes Rate Limiting Integration', () => {
    let app;
    let notificationService;

    beforeAll(() => {
        // Set test environment to skip rate limiting
        process.env.NODE_ENV = 'test';
    });

    beforeEach(() => {
        // Create a fresh app instance for each test
        app = express();
        app.use(express.json());
        
        // Import the routes after mocking
        const notificationRoutes = require('../../../src/routes/notifications');
        app.use('/api/notifications', notificationRoutes);

        // Get the mocked service
        notificationService = require('../../../src/services/notificationService');
        
        // Clear all mocks
        jest.clearAllMocks();
    });

    afterAll(() => {
        delete process.env.NODE_ENV;
    });

    describe('GET /api/notifications', () => {
        beforeEach(() => {
            notificationService.getUserNotifications.mockResolvedValue({
                success: true,
                data: [
                    {
                        id: 'notif-1',
                        type: 'payment_failed',
                        title: 'Payment Failed',
                        message: 'Your payment could not be processed',
                        status: 'unread',
                        created_at: new Date().toISOString()
                    }
                ],
                count: 1
            });
        });

        it('should successfully get notifications with rate limiting applied', async () => {
            const response = await request(app)
                .get('/api/notifications')
                .expect(200);

            expect(response.body.success).toBe(true);
            expect(response.body.data.notifications).toHaveLength(1);
            expect(notificationService.getUserNotifications).toHaveBeenCalledWith(
                'test-user-123',
                expect.objectContaining({
                    status: undefined,
                    type: undefined,
                    includeExpired: false,
                    limit: 50,
                    offset: 0
                })
            );
        });

        it('should handle query parameters correctly with rate limiting', async () => {
            const response = await request(app)
                .get('/api/notifications')
                .query({
                    status: 'unread',
                    type: 'payment_failed',
                    limit: 10,
                    offset: 5
                })
                .expect(200);

            expect(response.body.success).toBe(true);
            expect(notificationService.getUserNotifications).toHaveBeenCalledWith(
                'test-user-123',
                expect.objectContaining({
                    status: 'unread',
                    type: 'payment_failed',
                    includeExpired: false,
                    limit: 10,
                    offset: 5
                })
            );
        });

        it('should validate parameters and return errors', async () => {
            const response = await request(app)
                .get('/api/notifications')
                .query({
                    status: 'invalid-status'
                })
                .expect(400);

            expect(response.body.success).toBe(false);
            expect(response.body.error).toContain('Invalid status');
        });

        it('should include rate limit headers in response', async () => {
            const response = await request(app)
                .get('/api/notifications')
                .expect(200);

            // In test mode, rate limiting is skipped, but headers might still be present
            // This test verifies the middleware chain is working
            expect(response.body.success).toBe(true);
        });
    });

    describe('GET /api/notifications/count', () => {
        beforeEach(() => {
            notificationService.getUnreadCount.mockResolvedValue({
                success: true,
                count: 3
            });
        });

        it('should get unread count with rate limiting applied', async () => {
            const response = await request(app)
                .get('/api/notifications/count')
                .expect(200);

            expect(response.body.success).toBe(true);
            expect(response.body.data.unreadCount).toBe(3);
            expect(notificationService.getUnreadCount).toHaveBeenCalledWith('test-user-123');
        });

        it('should handle service errors gracefully', async () => {
            notificationService.getUnreadCount.mockResolvedValue({
                success: false,
                error: 'Database connection failed'
            });

            const response = await request(app)
                .get('/api/notifications/count')
                .expect(500);

            expect(response.body.success).toBe(false);
            expect(response.body.error).toBe('Database connection failed');
        });
    });

    describe('POST /api/notifications/:id/mark-read', () => {
        beforeEach(() => {
            notificationService.markAsRead.mockResolvedValue({
                success: true,
                data: {
                    id: 'notif-1',
                    status: 'read',
                    read_at: new Date().toISOString()
                }
            });
        });

        it('should mark notification as read with rate limiting applied', async () => {
            const response = await request(app)
                .post('/api/notifications/test-notification-id/mark-read')
                .expect(200);

            expect(response.body.success).toBe(true);
            expect(response.body.data.notification).toBeDefined();
            expect(notificationService.markAsRead).toHaveBeenCalledWith(
                'test-user-123',
                'test-notification-id'
            );
        });

        it('should validate notification ID', async () => {
            const response = await request(app)
                .post('/api/notifications//mark-read') // Empty ID
                .expect(404); // Express will return 404 for malformed route

            expect(notificationService.markAsRead).not.toHaveBeenCalled();
        });

        it('should handle notification not found', async () => {
            notificationService.markAsRead.mockResolvedValue({
                success: false,
                error: 'No rows found'
            });

            const response = await request(app)
                .post('/api/notifications/non-existent-id/mark-read')
                .expect(404);

            expect(response.body.success).toBe(false);
            expect(response.body.error).toBe('Notification not found');
        });
    });

    describe('POST /api/notifications/mark-all-read', () => {
        beforeEach(() => {
            notificationService.markAllAsRead.mockResolvedValue({
                success: true,
                count: 5
            });
        });

        it('should mark all notifications as read with rate limiting applied', async () => {
            const response = await request(app)
                .post('/api/notifications/mark-all-read')
                .expect(200);

            expect(response.body.success).toBe(true);
            expect(response.body.data.markedAsRead).toBe(5);
            expect(notificationService.markAllAsRead).toHaveBeenCalledWith('test-user-123');
        });

        it('should handle service errors', async () => {
            notificationService.markAllAsRead.mockResolvedValue({
                success: false,
                error: 'Service unavailable'
            });

            const response = await request(app)
                .post('/api/notifications/mark-all-read')
                .expect(500);

            expect(response.body.success).toBe(false);
            expect(response.body.error).toBe('Service unavailable');
        });
    });

    describe('GET /api/notifications/banners', () => {
        beforeEach(() => {
            notificationService.getUserNotifications.mockResolvedValue({
                success: true,
                data: [
                    {
                        id: 'banner-1',
                        type: 'payment_failed',
                        title: 'Payment Issue',
                        message: 'Please update your payment method',
                        status: 'unread',
                        show_banner: true,
                        priority: 'high',
                        created_at: new Date().toISOString()
                    },
                    {
                        id: 'banner-2',
                        type: 'subscription_canceled',
                        title: 'Subscription Canceled',
                        message: 'Your subscription has been canceled',
                        status: 'unread',
                        show_banner: true,
                        priority: 'urgent',
                        created_at: new Date().toISOString()
                    }
                ],
                count: 2
            });
        });

        it('should get banner notifications with rate limiting applied', async () => {
            const response = await request(app)
                .get('/api/notifications/banners')
                .expect(200);

            expect(response.body.success).toBe(true);
            expect(response.body.data.banners).toHaveLength(2);
            
            // Verify priority sorting (urgent should come first)
            expect(response.body.data.banners[0].priority).toBe('urgent');
            expect(response.body.data.banners[1].priority).toBe('high');

            expect(notificationService.getUserNotifications).toHaveBeenCalledWith(
                'test-user-123',
                {
                    status: 'unread',
                    includeExpired: false,
                    limit: 10
                }
            );
        });

        it('should handle empty banner notifications', async () => {
            notificationService.getUserNotifications.mockResolvedValue({
                success: true,
                data: [],
                count: 0
            });

            const response = await request(app)
                .get('/api/notifications/banners')
                .expect(200);

            expect(response.body.success).toBe(true);
            expect(response.body.data.banners).toHaveLength(0);
        });
    });

    describe('DELETE /api/notifications/:id', () => {
        beforeEach(() => {
            const { supabaseServiceClient } = require('../../../src/config/supabase');
            supabaseServiceClient.single.mockResolvedValue({
                data: {
                    id: 'notif-1',
                    status: 'archived',
                    archived_at: new Date().toISOString()
                },
                error: null
            });
        });

        it('should archive notification with rate limiting applied', async () => {
            const response = await request(app)
                .delete('/api/notifications/test-notification-id')
                .expect(200);

            expect(response.body.success).toBe(true);
            expect(response.body.data.notification).toBeDefined();

            const { supabaseServiceClient } = require('../../../src/config/supabase');
            expect(supabaseServiceClient.from).toHaveBeenCalledWith('user_notifications');
            expect(supabaseServiceClient.update).toHaveBeenCalledWith({ status: 'archived' });
            expect(supabaseServiceClient.eq).toHaveBeenCalledWith('id', 'test-notification-id');
            expect(supabaseServiceClient.eq).toHaveBeenCalledWith('user_id', 'test-user-123');
        });

        it('should handle notification not found', async () => {
            const { supabaseServiceClient } = require('../../../src/config/supabase');
            supabaseServiceClient.single.mockResolvedValue({
                data: null,
                error: { details: 'No row found with 0 rows' }
            });

            const response = await request(app)
                .delete('/api/notifications/non-existent-id')
                .expect(404);

            expect(response.body.success).toBe(false);
            expect(response.body.error).toBe('Notification not found');
        });

        it('should validate notification ID', async () => {
            const response = await request(app)
                .delete('/api/notifications/') // Empty ID
                .expect(404); // Express returns 404 for malformed route
        });
    });

    describe('Rate limiting behavior simulation', () => {
        it('should allow multiple requests within test environment', async () => {
            notificationService.getUserNotifications.mockResolvedValue({
                success: true,
                data: [],
                count: 0
            });

            // Make multiple rapid requests - should all succeed in test mode
            const promises = [];
            for (let i = 0; i < 10; i++) {
                promises.push(request(app).get('/api/notifications'));
            }

            const responses = await Promise.all(promises);
            responses.forEach(response => {
                expect(response.status).toBe(200);
                expect(response.body.success).toBe(true);
            });

            // Verify all requests were processed
            expect(notificationService.getUserNotifications).toHaveBeenCalledTimes(10);
        });

        it('should apply different rate limits to different endpoint types', async () => {
            // Mock responses for different endpoints
            notificationService.getUserNotifications.mockResolvedValue({
                success: true,
                data: [],
                count: 0
            });
            
            notificationService.markAsRead.mockResolvedValue({
                success: true,
                data: { id: 'test' }
            });

            notificationService.getUnreadCount.mockResolvedValue({
                success: true,
                count: 0
            });

            // Test that different endpoints can be called without interfering
            await request(app).get('/api/notifications').expect(200);
            await request(app).post('/api/notifications/test-id/mark-read').expect(200);
            await request(app).get('/api/notifications/count').expect(200);

            // All should succeed in test environment
            expect(notificationService.getUserNotifications).toHaveBeenCalledTimes(1);
            expect(notificationService.markAsRead).toHaveBeenCalledTimes(1);
            expect(notificationService.getUnreadCount).toHaveBeenCalledTimes(1);
        });
    });

    describe('Error handling with rate limiting', () => {
        it('should handle service errors correctly even with rate limiting', async () => {
            notificationService.getUserNotifications.mockRejectedValue(
                new Error('Database connection failed')
            );

            const response = await request(app)
                .get('/api/notifications')
                .expect(500);

            expect(response.body.success).toBe(false);
            expect(response.body.error).toBe('Failed to fetch notifications');
        });

        it('should handle invalid request data with rate limiting', async () => {
            const response = await request(app)
                .get('/api/notifications')
                .query({ type: 'invalid-type' })
                .expect(400);

            expect(response.body.success).toBe(false);
            expect(response.body.error).toContain('Invalid notification type');
        });
    });
});