/**\n * Integration Tests for Complete Usage Tracking System\n * \n * These tests verify the end-to-end flow of usage tracking,\n * from worker operations through database recording to limit enforcement.\n */\n\nconst request = require('supertest');\nconst { createClient } = require('@supabase/supabase-js');\nconst GenerateReplyWorker = require('../../src/workers/GenerateReplyWorker');\nconst FetchCommentsWorker = require('../../src/workers/FetchCommentsWorker');\nconst AnalyzeToxicityWorker = require('../../src/workers/AnalyzeToxicityWorker');\nconst ShieldActionWorker = require('../../src/workers/ShieldActionWorker');\nconst CostControlService = require('../../src/services/costControl');\nconst app = require('../../src/index');\n\n// Test configuration\nconst testConfig = {\n  supabaseUrl: process.env.SUPABASE_URL || 'http://localhost:54321',\n  supabaseKey: process.env.SUPABASE_ANON_KEY || 'test-key',\n  testTimeout: 30000\n};\n\ndescribe('Usage Tracking Integration Flow', () => {\n  let supabase;\n  let costControl;\n  let testOrgId;\n  let testUserId;\n  let testCommentId;\n  let adminAuthToken;\n\n  beforeAll(async () => {\n    // Initialize test clients\n    supabase = createClient(testConfig.supabaseUrl, testConfig.supabaseKey);\n    costControl = new CostControlService();\n    \n    // Setup test data\n    await setupTestData();\n  }, testConfig.testTimeout);\n\n  afterAll(async () => {\n    // Cleanup test data\n    await cleanupTestData();\n  });\n\n  beforeEach(() => {\n    jest.setTimeout(testConfig.testTimeout);\n  });\n\n  /**\n   * Test the complete flow: Comment → Toxicity Analysis → Reply Generation → Usage Recording\n   */\n  describe('End-to-End Usage Tracking Flow', () => {\n    it('should track usage through complete comment processing pipeline', async () => {\n      // Step 1: Create a test comment\n      const { data: comment, error: commentError } = await supabase\n        .from('comments')\n        .insert({\n          organization_id: testOrgId,\n          integration_config_id: 'test-config-id',\n          platform: 'twitter',\n          platform_comment_id: 'twitter-123',\n          platform_user_id: 'user-456',\n          platform_username: 'testuser',\n          original_text: 'This is a test comment that needs analysis',\n          status: 'pending'\n        })\n        .select()\n        .single();\n      \n      expect(commentError).toBeNull();\n      testCommentId = comment.id;\n\n      // Step 2: Process toxicity analysis\n      const toxicityWorker = new AnalyzeToxicityWorker({ testing: true });\n      const toxicityJob = {\n        payload: {\n          comment_id: testCommentId,\n          organization_id: testOrgId,\n          platform: 'twitter',\n          text: comment.original_text\n        }\n      };\n\n      const toxicityResult = await toxicityWorker.processJob(toxicityJob);\n      expect(toxicityResult.success).toBe(true);\n\n      // Verify toxicity analysis usage was recorded\n      const { data: toxicityUsage } = await supabase\n        .from('usage_tracking')\n        .select('*')\n        .eq('organization_id', testOrgId)\n        .eq('resource_type', 'comment_analysis')\n        .eq('platform', 'twitter')\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .single();\n\n      expect(toxicityUsage).toBeTruthy();\n      expect(toxicityUsage.quantity).toBe(1);\n      expect(toxicityUsage.resource_type).toBe('comment_analysis');\n\n      // Step 3: Process reply generation\n      const replyWorker = new GenerateReplyWorker({ testing: true });\n      const replyJob = {\n        payload: {\n          comment_id: testCommentId,\n          organization_id: testOrgId,\n          platform: 'twitter',\n          original_text: comment.original_text,\n          toxicity_score: 0.6,\n          severity_level: 'medium',\n          categories: ['insult']\n        }\n      };\n\n      const replyResult = await replyWorker.processJob(replyJob);\n      expect(replyResult.success).toBe(true);\n\n      // Verify reply generation usage was recorded\n      const { data: replyUsage } = await supabase\n        .from('usage_tracking')\n        .select('*')\n        .eq('organization_id', testOrgId)\n        .eq('resource_type', 'roasts')\n        .eq('platform', 'twitter')\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .single();\n\n      expect(replyUsage).toBeTruthy();\n      expect(replyUsage.quantity).toBe(1);\n      expect(replyUsage.cost_cents).toBeGreaterThan(0);\n      expect(replyUsage.tokens_used).toBeGreaterThan(0);\n\n      // Step 4: Verify monthly usage summary was updated\n      const currentDate = new Date();\n      const { data: monthlyUsage } = await supabase\n        .from('monthly_usage')\n        .select('*')\n        .eq('organization_id', testOrgId)\n        .eq('year', currentDate.getFullYear())\n        .eq('month', currentDate.getMonth() + 1)\n        .single();\n\n      expect(monthlyUsage).toBeTruthy();\n      expect(monthlyUsage.total_responses).toBeGreaterThan(0);\n      expect(monthlyUsage.usage_by_resource).toHaveProperty('roasts');\n      expect(monthlyUsage.usage_by_resource).toHaveProperty('comment_analysis');\n    }, testConfig.testTimeout);\n\n    it('should enforce usage limits and block operations when exceeded', async () => {\n      // Set a low limit for testing\n      await costControl.setUsageLimit(testOrgId, 'roasts', 2, {\n        hardLimit: true,\n        allowOverage: false\n      });\n\n      // Generate replies up to the limit\n      const replyWorker = new GenerateReplyWorker({ testing: true });\n      \n      // First reply - should succeed\n      let job = {\n        payload: {\n          comment_id: testCommentId,\n          organization_id: testOrgId,\n          platform: 'twitter',\n          original_text: 'First test comment'\n        }\n      };\n      \n      let result = await replyWorker.processJob(job);\n      expect(result.success).toBe(true);\n\n      // Second reply - should succeed\n      job.payload.original_text = 'Second test comment';\n      result = await replyWorker.processJob(job);\n      expect(result.success).toBe(true);\n\n      // Third reply - should fail due to limit\n      job.payload.original_text = 'Third test comment';\n      await expect(replyWorker.processJob(job))\n        .rejects.toThrow(/has reached limits/);\n    }, testConfig.testTimeout);\n\n    it('should allow overage when configured', async () => {\n      // Set a limit with overage allowed\n      await costControl.setUsageLimit(testOrgId, 'api_calls', 1, {\n        hardLimit: false,\n        allowOverage: true,\n        overageRateCents: 1\n      });\n\n      const fetchWorker = new FetchCommentsWorker({ testing: true });\n      \n      // First API call - within limit\n      let job = {\n        payload: {\n          organization_id: testOrgId,\n          platform: 'twitter',\n          integration_config_id: 'test-config'\n        }\n      };\n      \n      let result = await fetchWorker.processJob(job);\n      expect(result.success).toBe(true);\n\n      // Second API call - should succeed with overage\n      result = await fetchWorker.processJob(job);\n      expect(result.success).toBe(true);\n\n      // Verify overage was recorded\n      const { data: monthlyUsage } = await supabase\n        .from('monthly_usage')\n        .select('*')\n        .eq('organization_id', testOrgId)\n        .single();\n\n      expect(monthlyUsage.overage_amount).toBeGreaterThan(0);\n    }, testConfig.testTimeout);\n  });\n\n  /**\n   * Test admin API endpoints for usage management\n   */\n  describe('Admin Usage Management API', () => {\n    it('should retrieve usage statistics via admin API', async () => {\n      const response = await request(app)\n        .get('/api/admin/usage')\n        .set('Authorization', `Bearer ${adminAuthToken}`)\n        .query({\n          period: 'current_month',\n          organization_id: testOrgId\n        });\n\n      expect(response.status).toBe(200);\n      expect(response.body.success).toBe(true);\n      expect(response.body.data).toHaveProperty('usage_records');\n      expect(response.body.data).toHaveProperty('summary');\n      expect(response.body.data).toHaveProperty('pagination');\n    });\n\n    it('should allow admin to set usage limits', async () => {\n      const response = await request(app)\n        .post('/api/admin/usage/limits')\n        .set('Authorization', `Bearer ${adminAuthToken}`)\n        .send({\n          organization_id: testOrgId,\n          resource_type: 'roasts',\n          monthly_limit: 500,\n          allow_overage: true,\n          overage_rate_cents: 2\n        });\n\n      expect(response.status).toBe(200);\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.monthly_limit).toBe(500);\n    });\n\n    it('should export usage data as CSV', async () => {\n      const response = await request(app)\n        .get('/api/admin/usage/export')\n        .set('Authorization', `Bearer ${adminAuthToken}`)\n        .query({\n          period: 'current_month',\n          format: 'csv',\n          organization_id: testOrgId\n        });\n\n      expect(response.status).toBe(200);\n      expect(response.headers['content-type']).toContain('text/csv');\n      expect(response.text).toContain('Organization,Plan,Resource Type');\n    });\n\n    it('should get detailed organization usage stats', async () => {\n      const response = await request(app)\n        .get(`/api/admin/usage/organizations/${testOrgId}`)\n        .set('Authorization', `Bearer ${adminAuthToken}`)\n        .query({ months: 1 });\n\n      expect(response.status).toBe(200);\n      expect(response.body.success).toBe(true);\n      expect(response.body.data).toHaveProperty('organizationId', testOrgId);\n      expect(response.body.data).toHaveProperty('currentMonth');\n      expect(response.body.data.currentMonth).toHaveProperty('usageByResource');\n      expect(response.body.data.currentMonth).toHaveProperty('usageByPlatform');\n    });\n  });\n\n  /**\n   * Test monthly usage reset functionality\n   */\n  describe('Monthly Usage Reset', () => {\n    it('should reset monthly usage counters', async () => {\n      // Ensure there's some usage to reset\n      await costControl.recordUsage(\n        testOrgId,\n        'twitter',\n        'generate_reply',\n        { test: true },\n        null,\n        1\n      );\n\n      // Check usage before reset\n      const { data: beforeReset } = await supabase\n        .from('organizations')\n        .select('monthly_responses_used')\n        .eq('id', testOrgId)\n        .single();\n\n      expect(beforeReset.monthly_responses_used).toBeGreaterThan(0);\n\n      // Perform reset\n      const resetResult = await costControl.resetAllMonthlyUsage();\n      expect(resetResult.success).toBe(true);\n      expect(resetResult.organizationsReset).toBeGreaterThan(0);\n\n      // Check usage after reset\n      const { data: afterReset } = await supabase\n        .from('organizations')\n        .select('monthly_responses_used')\n        .eq('id', testOrgId)\n        .single();\n\n      expect(afterReset.monthly_responses_used).toBe(0);\n    });\n\n    it('should handle reset via admin API with confirmation', async () => {\n      // First attempt without confirmation - should fail\n      let response = await request(app)\n        .post('/api/admin/usage/reset')\n        .set('Authorization', `Bearer ${adminAuthToken}`)\n        .send({ confirm: false });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toContain('confirmation');\n\n      // Second attempt with confirmation - should succeed\n      response = await request(app)\n        .post('/api/admin/usage/reset')\n        .set('Authorization', `Bearer ${adminAuthToken}`)\n        .send({ confirm: true });\n\n      expect(response.status).toBe(200);\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.organizationsReset).toBeGreaterThan(0);\n    });\n  });\n\n  /**\n   * Test usage alerts and notifications\n   */\n  describe('Usage Alerts', () => {\n    it('should trigger alerts when approaching usage limits', async () => {\n      // Set a low limit to trigger alerts\n      await costControl.setUsageLimit(testOrgId, 'roasts', 10);\n      \n      // Create usage alert configuration\n      await supabase\n        .from('usage_alerts')\n        .upsert({\n          organization_id: testOrgId,\n          resource_type: 'roasts',\n          threshold_percentage: 80,\n          alert_type: 'email',\n          is_active: true\n        });\n\n      // Record usage that exceeds 80% threshold (8+ out of 10)\n      for (let i = 0; i < 9; i++) {\n        await costControl.recordUsage(\n          testOrgId,\n          'twitter',\n          'generate_reply',\n          { alertTest: true, iteration: i },\n          null,\n          1\n        );\n      }\n\n      // Check that alert was triggered (recorded in logs)\n      const { data: alertLogs } = await supabase\n        .from('app_logs')\n        .select('*')\n        .eq('organization_id', testOrgId)\n        .eq('category', 'billing')\n        .ilike('message', '%usage alert%')\n        .order('created_at', { ascending: false })\n        .limit(1);\n\n      expect(alertLogs.length).toBeGreaterThan(0);\n      expect(alertLogs[0].metadata).toHaveProperty('percentage');\n      expect(alertLogs[0].metadata.percentage).toBeGreaterThanOrEqual(80);\n    });\n  });\n\n  /**\n   * Test plan upgrade usage limit updates\n   */\n  describe('Plan Upgrade Usage Limits', () => {\n    it('should update usage limits when plan is upgraded', async () => {\n      // Start with free plan\n      await costControl.updatePlanUsageLimits(testOrgId, 'free');\n      \n      // Check free plan limits\n      const { data: freeLimits } = await supabase\n        .from('usage_limits')\n        .select('*')\n        .eq('organization_id', testOrgId)\n        .eq('resource_type', 'roasts')\n        .single();\n\n      expect(freeLimits.monthly_limit).toBe(100);\n      expect(freeLimits.allow_overage).toBe(false);\n      expect(freeLimits.hard_limit).toBe(true);\n\n      // Upgrade to pro plan\n      await costControl.upgradePlan(testOrgId, 'pro', 'stripe_sub_123');\n      \n      // Check pro plan limits\n      const { data: proLimits } = await supabase\n        .from('usage_limits')\n        .select('*')\n        .eq('organization_id', testOrgId)\n        .eq('resource_type', 'roasts')\n        .single();\n\n      expect(proLimits.monthly_limit).toBe(1000);\n      expect(proLimits.allow_overage).toBe(true);\n      expect(proLimits.hard_limit).toBe(false);\n    });\n  });\n\n  // Helper functions\n  async function setupTestData() {\n    // Create test organization\n    const { data: org, error: orgError } = await supabase\n      .from('organizations')\n      .insert({\n        name: 'Test Organization',\n        slug: 'test-org-usage-tracking',\n        plan_id: 'free',\n        monthly_responses_limit: 100\n      })\n      .select()\n      .single();\n\n    if (orgError) {\n      console.error('Failed to create test organization:', orgError);\n      throw orgError;\n    }\n    testOrgId = org.id;\n\n    // Create test user (admin)\n    const { data: user, error: userError } = await supabase\n      .from('users')\n      .insert({\n        email: 'admin@test-usage-tracking.com',\n        name: 'Test Admin',\n        is_admin: true,\n        active: true\n      })\n      .select()\n      .single();\n\n    if (userError) {\n      console.error('Failed to create test user:', userError);\n      throw userError;\n    }\n    testUserId = user.id;\n\n    // Create integration config\n    await supabase\n      .from('integration_configs')\n      .insert({\n        id: 'test-config-id',\n        organization_id: testOrgId,\n        platform: 'twitter',\n        enabled: true,\n        config: { auto_post: false },\n        tone: 'sarcastic',\n        humor_type: 'witty'\n      });\n\n    // Mock admin auth token\n    adminAuthToken = 'mock-admin-token-for-testing';\n  }\n\n  async function cleanupTestData() {\n    try {\n      // Delete in reverse order to respect foreign key constraints\n      if (testCommentId) {\n        await supabase.from('responses').delete().eq('comment_id', testCommentId);\n        await supabase.from('comments').delete().eq('id', testCommentId);\n      }\n      \n      if (testOrgId) {\n        await supabase.from('usage_tracking').delete().eq('organization_id', testOrgId);\n        await supabase.from('usage_limits').delete().eq('organization_id', testOrgId);\n        await supabase.from('usage_alerts').delete().eq('organization_id', testOrgId);\n        await supabase.from('monthly_usage').delete().eq('organization_id', testOrgId);\n        await supabase.from('integration_configs').delete().eq('organization_id', testOrgId);\n        await supabase.from('app_logs').delete().eq('organization_id', testOrgId);\n        await supabase.from('organizations').delete().eq('id', testOrgId);\n      }\n      \n      if (testUserId) {\n        await supabase.from('users').delete().eq('id', testUserId);\n      }\n    } catch (error) {\n      console.warn('Cleanup error (may be expected):', error.message);\n    }\n  }\n});"