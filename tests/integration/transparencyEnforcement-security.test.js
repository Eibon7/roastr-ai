/**
 * Integration Tests for Transparency Enforcement Security - Round 3 Fixes
 * Tests enhanced transparency validation, fail-closed patterns, and GDPR compliance
 */

const AutoApprovalService = require('../../src/services/autoApprovalService');
const transparencyService = require('../../src/services/transparencyService');

// Mock dependencies for integration testing
jest.mock('../../src/config/supabase', () => ({
  supabaseServiceClient: {
    from: jest.fn().mockReturnThis(),
    select: jest.fn().mockReturnThis(),
    eq: jest.fn().mockReturnThis(),
    single: jest.fn(),
    gte: jest.fn().mockReturnThis(),
    insert: jest.fn().mockReturnThis()
  }
}));

jest.mock('../../src/services/shieldService', () => {
  return jest.fn().mockImplementation(() => ({
    analyzeContent: jest.fn().mockResolvedValue({ action: 'allow' })
  }));
});

// Mock transparency service for controlled testing
jest.mock('../../src/services/transparencyService', () => ({
  isTransparencyRequired: jest.fn(),
  applyTransparency: jest.fn(),
  getTransparencySettings: jest.fn(),
  validateTransparencyCompliance: jest.fn()
}));

const { supabaseServiceClient } = require('../../src/config/supabase');

describe('Transparency Enforcement Security - Integration Tests', () => {
  let autoApprovalService;

  beforeEach(() => {
    autoApprovalService = new AutoApprovalService();
    jest.clearAllMocks();

    // Default mocks for successful organization and rate limiting
    supabaseServiceClient.single.mockResolvedValue({
      data: { plan: 'pro', settings: { auto_approval: true } },
      error: null
    });

    supabaseServiceClient.select
      .mockResolvedValueOnce({ data: [], error: null }) // Health check
      .mockResolvedValueOnce({ data: [], count: 5, error: null }) // Hourly
      .mockResolvedValueOnce({ data: [], count: 20, error: null }); // Daily

    supabaseServiceClient.insert.mockResolvedValue({
      data: { id: 'approval-1' },
      error: null
    });
  });

  describe('GDPR Transparency Compliance', () => {
    test('should enforce transparency for EU organizations', async () => {
      transparencyService.isTransparencyRequired.mockResolvedValue(true);
      transparencyService.applyTransparency.mockResolvedValue({
        text: 'Roasted response ðŸ¤– Generated by AI for transparency'
      });

      const comment = {
        id: 'comment-1',
        text: 'test comment',
        platform: 'twitter',
        user_location: 'EU'
      };
      const variant = { id: 'variant-1', text: 'Roasted response', score: 0.3 };

      const result = await autoApprovalService.processAutoApproval(comment, variant, 'eu-org');

      expect(result.approved).toBe(true);
      expect(result.variant.text).toContain('ðŸ¤–');
      expect(result.variant.text).toContain('Generated by AI');
      expect(transparencyService.isTransparencyRequired).toHaveBeenCalledWith('eu-org');
      expect(transparencyService.applyTransparency).toHaveBeenCalledWith(variant, 'eu-org');
    });

    test('should fail closed when transparency service is unavailable during GDPR requirement', async () => {
      transparencyService.isTransparencyRequired.mockRejectedValue(
        new Error('GDPR compliance service timeout')
      );

      const comment = { id: 'comment-1', text: 'test comment', platform: 'twitter' };
      const variant = { id: 'variant-1', text: 'test response', score: 0.3 };

      const result = await autoApprovalService.processAutoApproval(comment, variant, 'eu-org');

      expect(result.approved).toBe(false);
      expect(result.reason).toBe('transparency_system_error');
      expect(result.requiresManualReview).toBe(true);
      expect(result.error).toContain('GDPR compliance service timeout');
    });

    test('should validate multiple transparency indicator types', async () => {
      const transparencyIndicators = [
        'ðŸ¤– AI generated response',
        'This response was generated by artificial intelligence',
        'Generated by AI bot for your entertainment',
        'Automated response generated by our AI system'
      ];

      for (const indicator of transparencyIndicators) {
        transparencyService.isTransparencyRequired.mockResolvedValue(true);
        transparencyService.applyTransparency.mockResolvedValue({
          text: `Roast content ${indicator}`
        });

        const comment = { id: 'comment-1', text: 'test', platform: 'twitter' };
        const variant = { id: 'variant-1', text: 'test response', score: 0.3 };

        const result = await autoApprovalService.processAutoApproval(comment, variant, 'test-org');

        expect(result.approved).toBe(true);
        expect(result.variant.text).toContain(indicator);
      }
    });

    test('should reject responses without proper transparency indicators', async () => {
      const invalidResponses = [
        'Just a regular roast without indicators',
        'Response with emoji ðŸ˜€ but not transparency emoji',
        'Response mentioning AI but not properly formatted',
        'Response with bot word in middle of sentence but not indicating AI'
      ];

      for (const invalidResponse of invalidResponses) {
        transparencyService.isTransparencyRequired.mockResolvedValue(true);
        transparencyService.applyTransparency.mockResolvedValue({
          text: invalidResponse
        });

        const comment = { id: 'comment-1', text: 'test', platform: 'twitter' };
        const variant = { id: 'variant-1', text: 'test response', score: 0.3 };

        const result = await autoApprovalService.processAutoApproval(comment, variant, 'test-org');

        expect(result.approved).toBe(false);
        expect(result.reason).toBe('transparency_validation_failed');
        expect(result.requiresManualReview).toBe(true);
      }
    });
  });

  describe('Transparency Service Integration Failures', () => {
    test('should handle transparency service returning null/undefined', async () => {
      transparencyService.isTransparencyRequired.mockResolvedValue(true);
      transparencyService.applyTransparency.mockResolvedValue(null);

      const comment = { id: 'comment-1', text: 'test', platform: 'twitter' };
      const variant = { id: 'variant-1', text: 'test response', score: 0.3 };

      const result = await autoApprovalService.processAutoApproval(comment, variant, 'test-org');

      expect(result.approved).toBe(false);
      expect(result.reason).toBe('transparency_enforcement_failed');
      expect(result.error).toBe('Required transparency was not applied');
    });

    test('should handle transparency service returning same text', async () => {
      const originalText = 'Original response text';

      transparencyService.isTransparencyRequired.mockResolvedValue(true);
      transparencyService.applyTransparency.mockResolvedValue({
        text: originalText // Same as original
      });

      const comment = { id: 'comment-1', text: 'test', platform: 'twitter' };
      const variant = { id: 'variant-1', text: originalText, score: 0.3 };

      const result = await autoApprovalService.processAutoApproval(comment, variant, 'test-org');

      expect(result.approved).toBe(false);
      expect(result.reason).toBe('transparency_enforcement_failed');
      expect(result.error).toBe('Required transparency was not applied');
    });

    test('should handle transparency service network failures', async () => {
      transparencyService.isTransparencyRequired.mockResolvedValue(true);
      transparencyService.applyTransparency.mockRejectedValue(
        new Error('Network timeout connecting to transparency service')
      );

      const comment = { id: 'comment-1', text: 'test', platform: 'twitter' };
      const variant = { id: 'variant-1', text: 'test response', score: 0.3 };

      const result = await autoApprovalService.processAutoApproval(comment, variant, 'test-org');

      expect(result.approved).toBe(false);
      expect(result.reason).toBe('transparency_system_error');
      expect(result.requiresManualReview).toBe(true);
      expect(result.error).toContain('Network timeout');
    });

    test('should handle transparency service malformed responses', async () => {
      const malformedResponses = [
        undefined,
        null,
        '',
        {
          /* missing text property */
        },
        { text: null },
        { text: undefined },
        { text: '' }
      ];

      for (const malformedResponse of malformedResponses) {
        transparencyService.isTransparencyRequired.mockResolvedValue(true);
        transparencyService.applyTransparency.mockResolvedValue(malformedResponse);

        const comment = { id: 'comment-1', text: 'test', platform: 'twitter' };
        const variant = { id: 'variant-1', text: 'test response', score: 0.3 };

        const result = await autoApprovalService.processAutoApproval(comment, variant, 'test-org');

        expect(result.approved).toBe(false);
        expect(result.reason).toBe('transparency_enforcement_failed');
      }
    });
  });

  describe('Cross-Platform Transparency Requirements', () => {
    test('should enforce transparency consistently across platforms', async () => {
      const platforms = ['twitter', 'facebook', 'instagram', 'youtube'];

      transparencyService.isTransparencyRequired.mockResolvedValue(true);
      transparencyService.applyTransparency.mockResolvedValue({
        text: 'Platform response ðŸ¤– AI generated'
      });

      for (const platform of platforms) {
        const comment = {
          id: `comment-${platform}`,
          text: 'test comment',
          platform
        };
        const variant = {
          id: `variant-${platform}`,
          text: 'test response',
          score: 0.3
        };

        const result = await autoApprovalService.processAutoApproval(comment, variant, 'test-org');

        expect(result.approved).toBe(true);
        expect(result.variant.text).toContain('ðŸ¤–');
        expect(transparencyService.applyTransparency).toHaveBeenCalledWith(variant, 'test-org');
      }
    });

    test('should handle platform-specific transparency failures', async () => {
      transparencyService.isTransparencyRequired.mockResolvedValue(true);

      // Mock platform-specific failure
      transparencyService.applyTransparency.mockImplementation((variant, orgId) => {
        if (variant.id.includes('twitter')) {
          throw new Error('Twitter transparency service unavailable');
        }
        return Promise.resolve({
          text: `${variant.text} ðŸ¤– AI generated`
        });
      });

      // Test Twitter failure
      const twitterComment = { id: 'comment-twitter', text: 'test', platform: 'twitter' };
      const twitterVariant = { id: 'variant-twitter', text: 'test response', score: 0.3 };

      const twitterResult = await autoApprovalService.processAutoApproval(
        twitterComment,
        twitterVariant,
        'test-org'
      );

      expect(twitterResult.approved).toBe(false);
      expect(twitterResult.reason).toBe('transparency_system_error');

      // Test Facebook success
      const facebookComment = { id: 'comment-facebook', text: 'test', platform: 'facebook' };
      const facebookVariant = { id: 'variant-facebook', text: 'test response', score: 0.3 };

      const facebookResult = await autoApprovalService.processAutoApproval(
        facebookComment,
        facebookVariant,
        'test-org'
      );

      expect(facebookResult.approved).toBe(true);
      expect(facebookResult.variant.text).toContain('ðŸ¤–');
    });
  });

  describe('Organization-Specific Transparency Settings', () => {
    test('should respect organization transparency preferences', async () => {
      // Test organization that doesn't require transparency
      transparencyService.isTransparencyRequired.mockResolvedValue(false);

      const comment = { id: 'comment-1', text: 'test', platform: 'twitter' };
      const variant = { id: 'variant-1', text: 'test response', score: 0.3 };

      const result = await autoApprovalService.processAutoApproval(comment, variant, 'non-eu-org');

      expect(result.approved).toBe(true);
      expect(result.variant.text).toBe('test response'); // Unchanged
      expect(transparencyService.applyTransparency).not.toHaveBeenCalled();
    });

    test('should handle dynamic transparency requirement changes', async () => {
      // First call - transparency not required
      transparencyService.isTransparencyRequired.mockResolvedValueOnce(false);

      const comment1 = { id: 'comment-1', text: 'test', platform: 'twitter' };
      const variant1 = { id: 'variant-1', text: 'test response', score: 0.3 };

      const result1 = await autoApprovalService.processAutoApproval(comment1, variant1, 'test-org');

      expect(result1.approved).toBe(true);
      expect(result1.variant.text).toBe('test response');

      // Reset mocks for second call
      jest.clearAllMocks();
      supabaseServiceClient.single.mockResolvedValue({
        data: { plan: 'pro', settings: { auto_approval: true } },
        error: null
      });
      supabaseServiceClient.select
        .mockResolvedValueOnce({ data: [], error: null })
        .mockResolvedValueOnce({ data: [], count: 6, error: null })
        .mockResolvedValueOnce({ data: [], count: 21, error: null });
      supabaseServiceClient.insert.mockResolvedValue({
        data: { id: 'approval-2' },
        error: null
      });

      // Second call - transparency now required
      transparencyService.isTransparencyRequired.mockResolvedValueOnce(true);
      transparencyService.applyTransparency.mockResolvedValue({
        text: 'test response ðŸ¤– AI generated'
      });

      const comment2 = { id: 'comment-2', text: 'test', platform: 'twitter' };
      const variant2 = { id: 'variant-2', text: 'test response', score: 0.3 };

      const result2 = await autoApprovalService.processAutoApproval(comment2, variant2, 'test-org');

      expect(result2.approved).toBe(true);
      expect(result2.variant.text).toContain('ðŸ¤–');
    });
  });

  describe('Transparency Audit Trail', () => {
    test('should create audit trail for transparency enforcement', async () => {
      transparencyService.isTransparencyRequired.mockResolvedValue(true);
      transparencyService.applyTransparency.mockResolvedValue({
        text: 'Response with transparency ðŸ¤– AI-generated content'
      });

      const comment = { id: 'comment-1', text: 'test', platform: 'twitter' };
      const variant = { id: 'variant-1', text: 'original response', score: 0.3 };

      const result = await autoApprovalService.processAutoApproval(comment, variant, 'test-org');

      expect(result.approved).toBe(true);

      // Verify approval record includes transparency metadata
      expect(supabaseServiceClient.insert).toHaveBeenCalledWith(
        expect.objectContaining({
          metadata: expect.objectContaining({
            originalText: 'test',
            generatedText: expect.stringContaining('ðŸ¤–')
          })
        })
      );
    });

    test('should log transparency decisions for audit purposes', async () => {
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      transparencyService.isTransparencyRequired.mockResolvedValue(true);
      transparencyService.applyTransparency.mockResolvedValue({
        text: 'Transparent response ðŸ¤– Generated by AI'
      });

      const comment = { id: 'comment-audit', text: 'test', platform: 'twitter' };
      const variant = { id: 'variant-audit', text: 'test response', score: 0.3 };

      await autoApprovalService.processAutoApproval(comment, variant, 'audit-org');

      // Verify transparency decisions are logged (implementation may vary)
      // This is a placeholder for actual audit logging verification
      expect(transparencyService.isTransparencyRequired).toHaveBeenCalledWith('audit-org');

      consoleSpy.mockRestore();
    });
  });

  describe('Performance and Resilience', () => {
    test('should handle transparency service latency gracefully', async () => {
      transparencyService.isTransparencyRequired.mockImplementation(
        () => new Promise((resolve) => setTimeout(() => resolve(true), 100))
      );

      transparencyService.applyTransparency.mockImplementation(
        () =>
          new Promise((resolve) =>
            setTimeout(
              () =>
                resolve({
                  text: 'Delayed response ðŸ¤– AI generated'
                }),
              150
            )
          )
      );

      const startTime = Date.now();

      const comment = { id: 'comment-1', text: 'test', platform: 'twitter' };
      const variant = { id: 'variant-1', text: 'test response', score: 0.3 };

      const result = await autoApprovalService.processAutoApproval(comment, variant, 'test-org');

      const endTime = Date.now();
      const duration = endTime - startTime;

      expect(result.approved).toBe(true);
      expect(duration).toBeGreaterThan(200); // Should wait for both calls
      expect(result.variant.text).toContain('ðŸ¤–');
    });

    test('should handle concurrent transparency requests', async () => {
      transparencyService.isTransparencyRequired.mockResolvedValue(true);
      transparencyService.applyTransparency.mockImplementation((variant) =>
        Promise.resolve({
          text: `${variant.text} ðŸ¤– AI generated for ${variant.id}`
        })
      );

      const requests = [];
      for (let i = 0; i < 5; i++) {
        const comment = { id: `comment-${i}`, text: 'test', platform: 'twitter' };
        const variant = { id: `variant-${i}`, text: `response-${i}`, score: 0.3 };

        // Reset mocks for each request
        supabaseServiceClient.single.mockResolvedValue({
          data: { plan: 'pro', settings: { auto_approval: true } },
          error: null
        });
        supabaseServiceClient.select
          .mockResolvedValue({ data: [], error: null })
          .mockResolvedValue({ data: [], count: i + 1, error: null })
          .mockResolvedValue({ data: [], count: (i + 1) * 5, error: null });
        supabaseServiceClient.insert.mockResolvedValue({
          data: { id: `approval-${i}` },
          error: null
        });

        requests.push(autoApprovalService.processAutoApproval(comment, variant, `org-${i}`));
      }

      const results = await Promise.all(requests);

      results.forEach((result, index) => {
        expect(result.approved).toBe(true);
        expect(result.variant.text).toContain(`variant-${index}`);
        expect(result.variant.text).toContain('ðŸ¤–');
      });
    });
  });
});
