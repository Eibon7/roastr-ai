/**
 * Integration Tests for Transparency Enforcement Security - Round 3 Fixes
 * Tests enhanced transparency validation, fail-closed patterns, and GDPR compliance
 */

const AutoApprovalService = require('../../src/services/autoApprovalService');
const transparencyService = require('../../src/services/transparencyService');

// Mock dependencies for integration testing
jest.mock('../../src/config/supabase', () => ({
  supabaseServiceClient: {
    from: jest.fn().mockReturnThis(),
    select: jest.fn().mockReturnThis(),
    eq: jest.fn().mockReturnThis(),
    single: jest.fn(),
    gte: jest.fn().mockReturnThis(),
    insert: jest.fn().mockReturnThis()
  }
}));

jest.mock('../../src/services/shieldService', () => {
  return jest.fn().mockImplementation(() => ({
    analyzeContent: jest.fn().mockResolvedValue({ action: 'allow' })
  }));
});

// Mock transparency service for controlled testing
jest.mock('../../src/services/transparencyService', () => ({
  isTransparencyRequired: jest.fn(),
  applyTransparency: jest.fn(),
  getTransparencySettings: jest.fn(),
  validateTransparencyCompliance: jest.fn()
}));

const { supabaseServiceClient } = require('../../src/config/supabase');

describe('Transparency Enforcement Security - Integration Tests', () => {
  let autoApprovalService;

  beforeEach(() => {
    autoApprovalService = new AutoApprovalService();
    jest.clearAllMocks();

    // Default mocks for successful organization and rate limiting
    supabaseServiceClient.single.mockResolvedValue({
      data: { plan: 'pro', settings: { auto_approval: true } },
      error: null
    });

    supabaseServiceClient.select
      .mockResolvedValueOnce({ data: [], error: null }) // Health check
      .mockResolvedValueOnce({ data: [], count: 5, error: null }) // Hourly
      .mockResolvedValueOnce({ data: [], count: 20, error: null }); // Daily

    supabaseServiceClient.insert.mockResolvedValue({
      data: { id: 'approval-1' },
      error: null
    });
  });

  describe('GDPR Transparency Compliance', () => {
    test('should enforce transparency for EU organizations', async () => {
      transparencyService.isTransparencyRequired.mockResolvedValue(true);
      transparencyService.applyTransparency.mockResolvedValue({
        text: 'Roasted response ðŸ¤– Generated by AI for transparency'
      });

      const comment = { 
        id: 'comment-1', 
        text: 'test comment', 
        platform: 'twitter',
        user_location: 'EU'
      };
      const variant = { id: 'variant-1', text: 'Roasted response', score: 0.3 };

      const result = await autoApprovalService.processAutoApproval(comment, variant, 'eu-org');
      
      expect(result.approved).toBe(true);
      expect(result.variant.text).toContain('ðŸ¤–');
      expect(result.variant.text).toContain('Generated by AI');
      expect(transparencyService.isTransparencyRequired).toHaveBeenCalledWith('eu-org');
      expect(transparencyService.applyTransparency).toHaveBeenCalledWith(variant, 'eu-org');
    });

    test('should fail closed when transparency service is unavailable during GDPR requirement', async () => {
      transparencyService.isTransparencyRequired.mockRejectedValue(
        new Error('GDPR compliance service timeout')
      );

      const comment = { id: 'comment-1', text: 'test comment', platform: 'twitter' };
      const variant = { id: 'variant-1', text: 'test response', score: 0.3 };

      const result = await autoApprovalService.processAutoApproval(comment, variant, 'eu-org');
      
      expect(result.approved).toBe(false);
      expect(result.reason).toBe('transparency_system_error');
      expect(result.requiresManualReview).toBe(true);
      expect(result.error).toContain('GDPR compliance service timeout');
    });

    test('should validate multiple transparency indicator types', async () => {
      const transparencyIndicators = [
        'ðŸ¤– AI generated response',
        'This response was generated by artificial intelligence',
        'Generated by AI bot for your entertainment',
        'Automated response generated by our AI system'
      ];

      for (const indicator of transparencyIndicators) {
        transparencyService.isTransparencyRequired.mockResolvedValue(true);
        transparencyService.applyTransparency.mockResolvedValue({
          text: `Roast content ${indicator}`
        });

        const comment = { id: 'comment-1', text: 'test', platform: 'twitter' };
        const variant = { id: 'variant-1', text: 'test response', score: 0.3 };

        const result = await autoApprovalService.processAutoApproval(comment, variant, 'test-org');
        
        expect(result.approved).toBe(true);
        expect(result.variant.text).toContain(indicator);
      }
    });

    test('should reject responses without proper transparency indicators', async () => {
      const invalidResponses = [
        'Just a regular roast without indicators',
        'Response with emoji ðŸ˜€ but not transparency emoji',
        'Response mentioning AI but not properly formatted',
        'Response with bot word in middle of sentence but not indicating AI'
      ];

      for (const invalidResponse of invalidResponses) {
        transparencyService.isTransparencyRequired.mockResolvedValue(true);
        transparencyService.applyTransparency.mockResolvedValue({
          text: invalidResponse
        });

        const comment = { id: 'comment-1', text: 'test', platform: 'twitter' };
        const variant = { id: 'variant-1', text: 'test response', score: 0.3 };

        const result = await autoApprovalService.processAutoApproval(comment, variant, 'test-org');
        
        expect(result.approved).toBe(false);
        expect(result.reason).toBe('transparency_validation_failed');
        expect(result.requiresManualReview).toBe(true);
      }
    });
  });

  describe('Transparency Service Integration Failures', () => {
    test('should handle transparency service returning null/undefined', async () => {
      transparencyService.isTransparencyRequired.mockResolvedValue(true);
      transparencyService.applyTransparency.mockResolvedValue(null);

      const comment = { id: 'comment-1', text: 'test', platform: 'twitter' };
      const variant = { id: 'variant-1', text: 'test response', score: 0.3 };

      const result = await autoApprovalService.processAutoApproval(comment, variant, 'test-org');
      
      expect(result.approved).toBe(false);
      expect(result.reason).toBe('transparency_enforcement_failed');
      expect(result.error).toBe('Required transparency was not applied');
    });

    test('should handle transparency service network failures', async () => {
      transparencyService.isTransparencyRequired.mockResolvedValue(true);
      transparencyService.applyTransparency.mockRejectedValue(
        new Error('Network timeout connecting to transparency service')
      );

      const comment = { id: 'comment-1', text: 'test', platform: 'twitter' };
      const variant = { id: 'variant-1', text: 'test response', score: 0.3 };

      const result = await autoApprovalService.processAutoApproval(comment, variant, 'test-org');
      
      expect(result.approved).toBe(false);
      expect(result.reason).toBe('transparency_system_error');
      expect(result.requiresManualReview).toBe(true);
      expect(result.error).toContain('Network timeout');
    });
  });

  describe('Cross-Platform Transparency Requirements', () => {
    test('should enforce transparency consistently across platforms', async () => {
      const platforms = ['twitter', 'facebook', 'instagram', 'youtube'];
      
      transparencyService.isTransparencyRequired.mockResolvedValue(true);
      transparencyService.applyTransparency.mockResolvedValue({
        text: 'Platform response ðŸ¤– AI generated'
      });

      for (const platform of platforms) {
        const comment = { 
          id: `comment-${platform}`, 
          text: 'test comment', 
          platform 
        };
        const variant = { 
          id: `variant-${platform}`, 
          text: 'test response', 
          score: 0.3 
        };

        const result = await autoApprovalService.processAutoApproval(comment, variant, 'test-org');
        
        expect(result.approved).toBe(true);
        expect(result.variant.text).toContain('ðŸ¤–');
        expect(transparencyService.applyTransparency).toHaveBeenCalledWith(
          variant, 
          'test-org'
        );
      }
    });

    test('should handle platform-specific transparency failures', async () => {
      transparencyService.isTransparencyRequired.mockResolvedValue(true);
      
      // Mock platform-specific failure
      transparencyService.applyTransparency.mockImplementation((variant, orgId) => {
        if (variant.id.includes('twitter')) {
          throw new Error('Twitter transparency service unavailable');
        }
        return Promise.resolve({
          text: `${variant.text} ðŸ¤– AI generated`
        });
      });

      // Test Twitter failure
      const twitterComment = { id: 'comment-twitter', text: 'test', platform: 'twitter' };
      const twitterVariant = { id: 'variant-twitter', text: 'test response', score: 0.3 };
      
      const twitterResult = await autoApprovalService.processAutoApproval(
        twitterComment, 
        twitterVariant, 
        'test-org'
      );
      
      expect(twitterResult.approved).toBe(false);
      expect(twitterResult.reason).toBe('transparency_system_error');

      // Test Facebook success
      const facebookComment = { id: 'comment-facebook', text: 'test', platform: 'facebook' };
      const facebookVariant = { id: 'variant-facebook', text: 'test response', score: 0.3 };
      
      const facebookResult = await autoApprovalService.processAutoApproval(
        facebookComment, 
        facebookVariant, 
        'test-org'
      );
      
      expect(facebookResult.approved).toBe(true);
      expect(facebookResult.variant.text).toContain('ðŸ¤–');
    });
  });

  describe('Organization-Specific Transparency Settings', () => {
    test('should respect organization transparency preferences', async () => {
      // Test organization that doesn't require transparency
      transparencyService.isTransparencyRequired.mockResolvedValue(false);

      const comment = { id: 'comment-1', text: 'test', platform: 'twitter' };
      const variant = { id: 'variant-1', text: 'test response', score: 0.3 };

      const result = await autoApprovalService.processAutoApproval(comment, variant, 'non-eu-org');
      
      expect(result.approved).toBe(true);
      expect(result.variant.text).toBe('test response'); // Unchanged
      expect(transparencyService.applyTransparency).not.toHaveBeenCalled();
    });
  });

  describe('Performance and Resilience', () => {
    test('should handle transparency service latency gracefully', async () => {
      transparencyService.isTransparencyRequired.mockImplementation(() => 
        new Promise(resolve => setTimeout(() => resolve(true), 100))
      );
      
      transparencyService.applyTransparency.mockImplementation(() => 
        new Promise(resolve => setTimeout(() => resolve({
          text: 'Delayed response ðŸ¤– AI generated'
        }), 150))
      );

      const startTime = Date.now();
      
      const comment = { id: 'comment-1', text: 'test', platform: 'twitter' };
      const variant = { id: 'variant-1', text: 'test response', score: 0.3 };

      const result = await autoApprovalService.processAutoApproval(comment, variant, 'test-org');
      
      const endTime = Date.now();
      const duration = endTime - startTime;
      
      expect(result.approved).toBe(true);
      expect(duration).toBeGreaterThan(200); // Should wait for both calls
      expect(result.variant.text).toContain('ðŸ¤–');
    });
  });
});